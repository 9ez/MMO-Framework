/*
Author: Gudakov Ramil Sergeevich a.k.a.Gauss
Гудаков Рамиль Сергеевич
Contacts : [ramil2085@mail.ru, ramil2085@gmail.com]
See for more information License.h.
*/
// File has been generated by ReflectionCodeGenerator version 1.0 build 22, at 2019_01_27 14:04:51.213
	
#include "BinaryMarshaller.h"
#include "UnpackHandler.h"

using namespace nsBinary;

void TBinaryMarshaller::SetLimitForCompression( int binarySize )
{
  mSetLimitForCompression = binarySize;
}
//-----------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::GetID( char* packedData, int size )
{
  auto pHeader = (THeader*) packedData;
  return pHeader->type;
}
//-----------------------------------------------------------------------------
void TBinaryMarshaller::PushIsNotNullptr( void* p )
{
  unsigned char isNullptr = p == nullptr ? 0 : 1;
  mPushMaster.PushNum( isNullptr );
}
//-----------------------------------------------------------------------------
bool TBinaryMarshaller::PopIsNotNullptr()
{
  unsigned char isNullptr;
  mPopMaster.PopNum( isNullptr );
  return ( isNullptr != 0 );
}
//-----------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::PrepareForUnpackPopMaster( char* packedData, int size )
{
  int headerSize = sizeof( THeader );
  THeader header;
  memcpy( &header, packedData, headerSize );
  char* pObj = packedData + headerSize;
  int objSize = size - headerSize;

  // decompression
  if ( header.useCompression )
  {
    mBuffer.Clear();
    mBuffer.Shift( objSize * header.ratio );// расширить для запаса под декомпрессию
    int decompressedRes = LZ4_decompress_safe( pObj, mBuffer.GetPtr(), objSize, mBuffer.GetSize() );
    mBuffer.Clear();
    mBuffer.Shift( decompressedRes );
  }
  else
  {
    mBuffer.Clear();
    mBuffer.Append( objSize, pObj );
  }
  mPopMaster.SetBuffer( &mBuffer, 0 );
  return header.type;
}
//-----------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::Unpack( char* packedData, int size )
{
  auto type = PrepareForUnpackPopMaster( packedData, size );
  switch( type )
  {
    case e_TBaseStruct:
    {
      auto p = Allocate<TBaseStruct>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TFloat3:
    {
      auto p = Allocate<TFloat3>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TFloat4:
    {
      auto p = Allocate<TFloat4>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TParamClass:
    {
      auto p = Allocate<TParamClass>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TTestClass:
    {
      auto p = Allocate<TTestClass>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TTestStruct:
    {
      auto p = Allocate<TTestStruct>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
  }
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TBaseStruct* p )
{
  mPushMaster.PushStr( p->s );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TBaseStruct* p )
{
  mPopMaster.PopStr( p->s );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TBaseStruct* p )
{
  return e_TBaseStruct;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TFloat3* p )
{
  mPushMaster.PushNum( p->x );
  mPushMaster.PushNum( p->y );
  mPushMaster.PushNum( p->z );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TFloat3* p )
{
  mPopMaster.PopNum( p->x );
  mPopMaster.PopNum( p->y );
  mPopMaster.PopNum( p->z );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TFloat3* p )
{
  return e_TFloat3;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TFloat4* p )
{
  mPushMaster.PushNum( p->x );
  mPushMaster.PushNum( p->y );
  mPushMaster.PushNum( p->z );
  mPushMaster.PushNum( p->w );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TFloat4* p )
{
  mPopMaster.PopNum( p->x );
  mPopMaster.PopNum( p->y );
  mPopMaster.PopNum( p->z );
  mPopMaster.PopNum( p->w );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TFloat4* p )
{
  return e_TFloat4;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TParamClass* p )
{
  mPushMaster.PushNum( p->id );
  auto pos_p = &(p->pos);
  PushIsNotNullptr( pos_p );
  if ( pos_p )
    _Serialize( pos_p );
  auto rot_p = &(p->rot);
  PushIsNotNullptr( rot_p );
  if ( rot_p )
    _Serialize( rot_p );
  auto vel_p = &(p->vel);
  PushIsNotNullptr( vel_p );
  if ( vel_p )
    _Serialize( vel_p );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TParamClass* p )
{
  mPopMaster.PopNum( p->id );
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->pos) );
  }
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->rot) );
  }
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->vel) );
  }
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TParamClass* p )
{
  return e_TParamClass;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TTestClass* p )
{
  mPushMaster.PushSerObjArray<TParamClass>( p->vParam, [this]( TParamClass* p ) { _Serialize( p ); } );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TTestClass* p )
{
  mPopMaster.PopSerObjArray<TParamClass>( p->vParam, [this]( TParamClass* p ) { _Deserialize( p ); } );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TTestClass* p )
{
  return e_TTestClass;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TTestStruct* p )
{
  _Serialize( (TBaseStruct*)p );
  auto baseStruct_p = &(p->baseStruct);
  PushIsNotNullptr( baseStruct_p );
  if ( baseStruct_p )
    _Serialize( baseStruct_p );
  auto pBaseStruct_p = p->pBaseStruct;
  PushIsNotNullptr( pBaseStruct_p );
  if ( pBaseStruct_p )
    _Serialize( pBaseStruct_p );
  auto spBaseStruct_p = p->spBaseStruct.get();
  PushIsNotNullptr( spBaseStruct_p );
  if ( spBaseStruct_p )
    _Serialize( spBaseStruct_p );
  mPushMaster.PushStr( p->password );
  mPushMaster.PushNum( p->port );
  mPushMaster.PushBool( p->flag );
  mPushMaster.PushStrArray( p->strSet );
  mPushMaster.PushNumArray<int>( p->intSet );
  mPushMaster.PushBoolArray( p->boolList );
  mPushMaster.PushNumArray<int>( p->numList );
  mPushMaster.PushNumArray<int>( p->numVector );
  mPushMaster.PushSerObjArray<TBaseStruct>( p->baseVec, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushSerPtrArray<TBaseStruct>( p->basePtrVec, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushSerSmartPtrArray<TBaseStruct, std::shared_ptr<TBaseStruct>>( p->baseSPVec, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumNumMap<int, int>( p->intIntMap );
  mPushMaster.PushNumBoolMap<int>( p->intBoolMap );
  mPushMaster.PushNumStrMap<int>( p->intStrMap );
  mPushMaster.PushStrStrMap( p->strStrMap );
  mPushMaster.PushStrNumMap<int>( p->strIntMap );
  mPushMaster.PushStrBoolMap( p->strBoolMap );
  mPushMaster.PushStrSerObjMap<TBaseStruct>( p->strBaseMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushStrSerPtrMap<TBaseStruct>( p->strBasePtrMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushStrSerSmartPtrMap<TBaseStruct, std::shared_ptr<TBaseStruct>>( p->strBaseSPMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumSerObjMap<int, TBaseStruct>( p->intBaseMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumSerPtrMap<int, TBaseStruct>( p->intBasePtrMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumSerSmartPtrMap<int, TBaseStruct, std::shared_ptr<TBaseStruct>>( p->intBaseSPMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TTestStruct* p )
{
  _Deserialize( (TBaseStruct*)p );
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->baseStruct) );
  }
  if ( PopIsNotNullptr() )
  {
    if ( p->pBaseStruct == nullptr  )
      p->pBaseStruct = new TBaseStruct();
    _Deserialize( p->pBaseStruct );
  }
  if ( PopIsNotNullptr() )
  {
    if ( p->spBaseStruct.get() == nullptr  )
      p->spBaseStruct.reset( new TBaseStruct() );
    _Deserialize( p->spBaseStruct.get() );
  }
  mPopMaster.PopStr( p->password );
  mPopMaster.PopNum( p->port );
  mPopMaster.PopBool( p->flag );
  mPopMaster.PopStrSet( p->strSet );
  mPopMaster.PopNumSet( p->intSet );
  mPopMaster.PopBoolArray( p->boolList );
  mPopMaster.PopNumArray<int>( p->numList );
  mPopMaster.PopNumArray<int>( p->numVector );
  mPopMaster.PopSerObjArray<TBaseStruct>( p->baseVec, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopSerPtrArray<TBaseStruct>( p->basePtrVec, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopSerSmartPtrArray<TBaseStruct, std::shared_ptr<TBaseStruct>>( p->baseSPVec, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumNumMap<int, int>( p->intIntMap );
  mPopMaster.PopNumBoolMap<int>( p->intBoolMap );
  mPopMaster.PopNumStrMap<int>( p->intStrMap );
  mPopMaster.PopStrStrMap( p->strStrMap );
  mPopMaster.PopStrNumMap<int>( p->strIntMap );
  mPopMaster.PopStrBoolMap( p->strBoolMap );
  mPopMaster.PopStrSerObjMap<TBaseStruct>( p->strBaseMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopStrSerPtrMap<TBaseStruct>( p->strBasePtrMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopStrSerSmartPtrMap<TBaseStruct, std::shared_ptr<TBaseStruct>>( p->strBaseSPMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumSerObjMap<int, TBaseStruct>( p->intBaseMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumSerPtrMap<int, TBaseStruct>( p->intBasePtrMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumSerSmartPtrMap<int, TBaseStruct, std::shared_ptr<TBaseStruct>>( p->intBaseSPMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TTestStruct* p )
{
  return e_TTestStruct;
}
//---------------------------------------------------------------------------------------
