/*
Author: Gudakov Ramil Sergeevich a.k.a.Gauss
Гудаков Рамиль Сергеевич
Contacts : [ramil2085@mail.ru, ramil2085@gmail.com]
See for more information LICENSE.md.
*/
// File has been generated by ReflectionCodeGenerator version 1.7 build 36, at 2019_02_08 10:05:43.235
	
#include "BinaryMarshaller.h"
#include "UnpackHandler.h"

using namespace nsBinary;

void TBinaryMarshaller::SetLimitForCompression( int binarySize )
{
  mSetLimitForCompression = binarySize;
}
//-----------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::GetID( char* packedData, int size )
{
  auto pHeader = (THeader*) packedData;
  return pHeader->type;
}
//-----------------------------------------------------------------------------
void TBinaryMarshaller::PushIsNotNullptr( void* p )
{
  unsigned char isNullptr = p == nullptr ? 0 : 1;
  mPushMaster.PushNum( isNullptr );
}
//-----------------------------------------------------------------------------
bool TBinaryMarshaller::PopIsNotNullptr()
{
  unsigned char isNullptr;
  mPopMaster.PopNum( isNullptr );
  return ( isNullptr != 0 );
}
//-----------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::PrepareForUnpackPopMaster( char* packedData, int size )
{
  int headerSize = sizeof( THeader );
  THeader header;
  memcpy( &header, packedData, headerSize );
  char* pObj = packedData + headerSize;
  int objSize = size - headerSize;

  // decompression
  if ( header.useCompression )
  {
    mBuffer.Clear();
    mBuffer.Shift( objSize * header.ratio );// расширить для запаса под декомпрессию
    int decompressedRes = LZ4_decompress_safe( pObj, mBuffer.GetPtr(), objSize, mBuffer.GetSize() );
    mBuffer.Clear();
    mBuffer.Shift( decompressedRes );
  }
  else
  {
    mBuffer.Clear();
    mBuffer.Append( objSize, pObj );
  }
  mPopMaster.SetBuffer( &mBuffer, 0 );
  return header.type;
}
//-----------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::Unpack( char* packedData, int size )
{
  auto type = PrepareForUnpackPopMaster( packedData, size );
  switch( type )
  {
    case e_TFloat3:
    {
      auto p = Allocate<TFloat3>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TFloat4:
    {
      auto p = Allocate<TFloat4>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TParamClass:
    {
      auto p = Allocate<TParamClass>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TTestClass:
    {
      auto p = Allocate<TTestClass>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsBS_TBaseStruct:
    {
      auto p = Allocate<nsBS::TBaseStruct>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsBS_TTestStruct:
    {
      auto p = Allocate<nsBS::TTestStruct>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
  }
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TFloat3* p )
{
  mPushMaster.PushNum( p->x );
  mPushMaster.PushNum( p->y );
  mPushMaster.PushNum( p->z );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TFloat3* p )
{
  mPopMaster.PopNum( p->x );
  mPopMaster.PopNum( p->y );
  mPopMaster.PopNum( p->z );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TFloat3* p )
{
  return e_TFloat3;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deallocate( TFloat3* p )
{
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TFloat4* p )
{
  mPushMaster.PushNum( p->x );
  mPushMaster.PushNum( p->y );
  mPushMaster.PushNum( p->z );
  mPushMaster.PushNum( p->w );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TFloat4* p )
{
  mPopMaster.PopNum( p->x );
  mPopMaster.PopNum( p->y );
  mPopMaster.PopNum( p->z );
  mPopMaster.PopNum( p->w );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TFloat4* p )
{
  return e_TFloat4;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deallocate( TFloat4* p )
{
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TParamClass* p )
{
  mPushMaster.PushNum( p->id );
  auto pos_p = &(p->pos);
  PushIsNotNullptr( pos_p );
  if ( pos_p )
    _Serialize( pos_p );
  auto rot_p = &(p->rot);
  PushIsNotNullptr( rot_p );
  if ( rot_p )
    _Serialize( rot_p );
  auto vel_p = &(p->vel);
  PushIsNotNullptr( vel_p );
  if ( vel_p )
    _Serialize( vel_p );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TParamClass* p )
{
  mPopMaster.PopNum( p->id );
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->pos) );
  }
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->rot) );
  }
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->vel) );
  }
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TParamClass* p )
{
  return e_TParamClass;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deallocate( TParamClass* p )
{
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TTestClass* p )
{
  
  TBinaryMaster::SizeType vParam_size0 = (TBinaryMaster::SizeType)(p->vParam.size());
  mPushMaster.PushNum( vParam_size0 );
  for ( auto& vParam_e0 : p->vParam )
  {
    bool vParam_isNotNull = &(vParam_e0) != nullptr;
    mPushMaster.PushBool( vParam_isNotNull );
    if ( vParam_isNotNull )
      _Serialize( &(vParam_e0) );
  }
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TTestClass* p )
{
  
  p->vParam.clear();
  TBinaryMaster::SizeType vParam_size0;
  mPopMaster.PopNum( vParam_size0 );
  for ( TBinaryMaster::SizeType vParam_i0 = 0 ; vParam_i0 < vParam_size0 ; vParam_i0++ ) 
  {
    TParamClass vParam_e0;
    bool vParam_IsNotNull;
    mPopMaster.PopBool( vParam_IsNotNull );
    if ( vParam_IsNotNull )
    {
      _Deserialize( &(vParam_e0) );
    }
    p->vParam.push_back( vParam_e0 );
  }
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TTestClass* p )
{
  return e_TTestClass;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deallocate( TTestClass* p )
{
  p->vParam.clear();
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsBS::TBaseStruct* p )
{
  mPushMaster.PushStr( p->s );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsBS::TBaseStruct* p )
{
  mPopMaster.PopStr( p->s );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsBS::TBaseStruct* p )
{
  return e_nsBS_TBaseStruct;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deallocate( nsBS::TBaseStruct* p )
{
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsBS::TTestStruct* p )
{
  _Serialize( (nsBS::TBaseStruct*)p );
  auto baseStruct_p = &(p->baseStruct);
  PushIsNotNullptr( baseStruct_p );
  if ( baseStruct_p )
    _Serialize( baseStruct_p );
  auto pBaseStruct_p = p->pBaseStruct;
  PushIsNotNullptr( pBaseStruct_p );
  if ( pBaseStruct_p )
    _Serialize( pBaseStruct_p );
  auto spBaseStruct_p = p->spBaseStruct.get();
  PushIsNotNullptr( spBaseStruct_p );
  if ( spBaseStruct_p )
    _Serialize( spBaseStruct_p );
  mPushMaster.PushStr( p->password );
  mPushMaster.PushNum( p->port );
  mPushMaster.PushBool( p->flag );
  mPushMaster.PushStrArray( p->strSet );
  mPushMaster.PushNumArray<int>( p->intSet );
  
  TBinaryMaster::SizeType boolList_size0 = (TBinaryMaster::SizeType)(p->boolList.size());
  mPushMaster.PushNum( boolList_size0 );
  for ( auto& boolList_e0 : p->boolList )
  {
    mPushMaster.PushBool( boolList_e0 );
  }
  
  TBinaryMaster::SizeType numList_size0 = (TBinaryMaster::SizeType)(p->numList.size());
  mPushMaster.PushNum( numList_size0 );
  for ( auto& numList_e0 : p->numList )
  {
    mPushMaster.PushNum( numList_e0 );
  }
  
  TBinaryMaster::SizeType numVector_size0 = (TBinaryMaster::SizeType)(p->numVector.size());
  mPushMaster.PushNum( numVector_size0 );
  for ( auto& numVector_e0 : p->numVector )
  {
    mPushMaster.PushNum( numVector_e0 );
  }
  
  TBinaryMaster::SizeType strVector_size0 = (TBinaryMaster::SizeType)(p->strVector.size());
  mPushMaster.PushNum( strVector_size0 );
  for ( auto& strVector_e0 : p->strVector )
  {
    mPushMaster.PushStr( strVector_e0 );
  }
  
  TBinaryMaster::SizeType baseVec_size0 = (TBinaryMaster::SizeType)(p->baseVec.size());
  mPushMaster.PushNum( baseVec_size0 );
  for ( auto& baseVec_e0 : p->baseVec )
  {
    bool baseVec_isNotNull = &(baseVec_e0) != nullptr;
    mPushMaster.PushBool( baseVec_isNotNull );
    if ( baseVec_isNotNull )
      _Serialize( &(baseVec_e0) );
  }
  
  TBinaryMaster::SizeType basePtrVec_size0 = (TBinaryMaster::SizeType)(p->basePtrVec.size());
  mPushMaster.PushNum( basePtrVec_size0 );
  for ( auto& basePtrVec_e0 : p->basePtrVec )
  {
    bool basePtrVec_isNotNull = basePtrVec_e0 != nullptr;
    mPushMaster.PushBool( basePtrVec_isNotNull );
    if ( basePtrVec_isNotNull )
      _Serialize( basePtrVec_e0 );
  }
  
  TBinaryMaster::SizeType baseSPVec_size0 = (TBinaryMaster::SizeType)(p->baseSPVec.size());
  mPushMaster.PushNum( baseSPVec_size0 );
  for ( auto& baseSPVec_e0 : p->baseSPVec )
  {
    bool baseSPVec_isNotNull = baseSPVec_e0.get() != nullptr;
    mPushMaster.PushBool( baseSPVec_isNotNull );
    if ( baseSPVec_isNotNull )
      _Serialize( baseSPVec_e0.get() );
  }
  
  TBinaryMaster::SizeType intIntMap_size0 = (TBinaryMaster::SizeType)(p->intIntMap.size());
  mPushMaster.PushNum( intIntMap_size0 );
  for ( auto& intIntMap_e0 : p->intIntMap )
  {
    mPushMaster.PushNum( intIntMap_e0.first );
    mPushMaster.PushNum( intIntMap_e0.second );
  }
  
  TBinaryMaster::SizeType intBoolMap_size0 = (TBinaryMaster::SizeType)(p->intBoolMap.size());
  mPushMaster.PushNum( intBoolMap_size0 );
  for ( auto& intBoolMap_e0 : p->intBoolMap )
  {
    mPushMaster.PushNum( intBoolMap_e0.first );
    mPushMaster.PushBool( intBoolMap_e0.second );
  }
  
  TBinaryMaster::SizeType intStrMap_size0 = (TBinaryMaster::SizeType)(p->intStrMap.size());
  mPushMaster.PushNum( intStrMap_size0 );
  for ( auto& intStrMap_e0 : p->intStrMap )
  {
    mPushMaster.PushNum( intStrMap_e0.first );
    mPushMaster.PushStr( intStrMap_e0.second );
  }
  
  TBinaryMaster::SizeType strStrMap_size0 = (TBinaryMaster::SizeType)(p->strStrMap.size());
  mPushMaster.PushNum( strStrMap_size0 );
  for ( auto& strStrMap_e0 : p->strStrMap )
  {
    mPushMaster.PushStr( strStrMap_e0.first );
    mPushMaster.PushStr( strStrMap_e0.second );
  }
  
  TBinaryMaster::SizeType strIntMap_size0 = (TBinaryMaster::SizeType)(p->strIntMap.size());
  mPushMaster.PushNum( strIntMap_size0 );
  for ( auto& strIntMap_e0 : p->strIntMap )
  {
    mPushMaster.PushStr( strIntMap_e0.first );
    mPushMaster.PushNum( strIntMap_e0.second );
  }
  
  TBinaryMaster::SizeType strBoolMap_size0 = (TBinaryMaster::SizeType)(p->strBoolMap.size());
  mPushMaster.PushNum( strBoolMap_size0 );
  for ( auto& strBoolMap_e0 : p->strBoolMap )
  {
    mPushMaster.PushStr( strBoolMap_e0.first );
    mPushMaster.PushBool( strBoolMap_e0.second );
  }
  
  TBinaryMaster::SizeType strBaseMap_size0 = (TBinaryMaster::SizeType)(p->strBaseMap.size());
  mPushMaster.PushNum( strBaseMap_size0 );
  for ( auto& strBaseMap_e0 : p->strBaseMap )
  {
    mPushMaster.PushStr( strBaseMap_e0.first );
    bool strBaseMap_isNotNull = &(strBaseMap_e0.second) != nullptr;
    mPushMaster.PushBool( strBaseMap_isNotNull );
    if ( strBaseMap_isNotNull )
      _Serialize( &(strBaseMap_e0.second) );
  }
  
  TBinaryMaster::SizeType strBasePtrMap_size0 = (TBinaryMaster::SizeType)(p->strBasePtrMap.size());
  mPushMaster.PushNum( strBasePtrMap_size0 );
  for ( auto& strBasePtrMap_e0 : p->strBasePtrMap )
  {
    mPushMaster.PushStr( strBasePtrMap_e0.first );
    bool strBasePtrMap_isNotNull = strBasePtrMap_e0.second != nullptr;
    mPushMaster.PushBool( strBasePtrMap_isNotNull );
    if ( strBasePtrMap_isNotNull )
      _Serialize( strBasePtrMap_e0.second );
  }
  
  TBinaryMaster::SizeType strBaseSPMap_size0 = (TBinaryMaster::SizeType)(p->strBaseSPMap.size());
  mPushMaster.PushNum( strBaseSPMap_size0 );
  for ( auto& strBaseSPMap_e0 : p->strBaseSPMap )
  {
    mPushMaster.PushStr( strBaseSPMap_e0.first );
    bool strBaseSPMap_isNotNull = strBaseSPMap_e0.second.get() != nullptr;
    mPushMaster.PushBool( strBaseSPMap_isNotNull );
    if ( strBaseSPMap_isNotNull )
      _Serialize( strBaseSPMap_e0.second.get() );
  }
  
  TBinaryMaster::SizeType intBaseMap_size0 = (TBinaryMaster::SizeType)(p->intBaseMap.size());
  mPushMaster.PushNum( intBaseMap_size0 );
  for ( auto& intBaseMap_e0 : p->intBaseMap )
  {
    mPushMaster.PushNum( intBaseMap_e0.first );
    bool intBaseMap_isNotNull = &(intBaseMap_e0.second) != nullptr;
    mPushMaster.PushBool( intBaseMap_isNotNull );
    if ( intBaseMap_isNotNull )
      _Serialize( &(intBaseMap_e0.second) );
  }
  
  TBinaryMaster::SizeType intBasePtrMap_size0 = (TBinaryMaster::SizeType)(p->intBasePtrMap.size());
  mPushMaster.PushNum( intBasePtrMap_size0 );
  for ( auto& intBasePtrMap_e0 : p->intBasePtrMap )
  {
    mPushMaster.PushNum( intBasePtrMap_e0.first );
    bool intBasePtrMap_isNotNull = intBasePtrMap_e0.second != nullptr;
    mPushMaster.PushBool( intBasePtrMap_isNotNull );
    if ( intBasePtrMap_isNotNull )
      _Serialize( intBasePtrMap_e0.second );
  }
  
  TBinaryMaster::SizeType intBaseSPMap_size0 = (TBinaryMaster::SizeType)(p->intBaseSPMap.size());
  mPushMaster.PushNum( intBaseSPMap_size0 );
  for ( auto& intBaseSPMap_e0 : p->intBaseSPMap )
  {
    mPushMaster.PushNum( intBaseSPMap_e0.first );
    bool intBaseSPMap_isNotNull = intBaseSPMap_e0.second.get() != nullptr;
    mPushMaster.PushBool( intBaseSPMap_isNotNull );
    if ( intBaseSPMap_isNotNull )
      _Serialize( intBaseSPMap_e0.second.get() );
  }
  
  TBinaryMaster::SizeType intArrArr_size0 = (TBinaryMaster::SizeType)(p->intArrArr.size());
  mPushMaster.PushNum( intArrArr_size0 );
  for ( auto& intArrArr_e0 : p->intArrArr )
  {
    TBinaryMaster::SizeType intArrArr_size1 = (TBinaryMaster::SizeType)(intArrArr_e0.size());
    mPushMaster.PushNum( intArrArr_size1 );
    for ( auto& intArrArr_e1 : intArrArr_e0 )
    {
      mPushMaster.PushNum( intArrArr_e1 );
    }
  }
  
  TBinaryMaster::SizeType strArrArr_size0 = (TBinaryMaster::SizeType)(p->strArrArr.size());
  mPushMaster.PushNum( strArrArr_size0 );
  for ( auto& strArrArr_e0 : p->strArrArr )
  {
    TBinaryMaster::SizeType strArrArr_size1 = (TBinaryMaster::SizeType)(strArrArr_e0.size());
    mPushMaster.PushNum( strArrArr_size1 );
    for ( auto& strArrArr_e1 : strArrArr_e0 )
    {
      mPushMaster.PushStr( strArrArr_e1 );
    }
  }
  
  TBinaryMaster::SizeType strArrMap_size0 = (TBinaryMaster::SizeType)(p->strArrMap.size());
  mPushMaster.PushNum( strArrMap_size0 );
  for ( auto& strArrMap_e0 : p->strArrMap )
  {
    TBinaryMaster::SizeType strArrMap_size1 = (TBinaryMaster::SizeType)(strArrMap_e0.second.size());
    mPushMaster.PushNum( strArrMap_size1 );
    mPushMaster.PushStr( strArrMap_e0.first );
    for ( auto& strArrMap_e1 : strArrMap_e0.second )
    {
      mPushMaster.PushStr( strArrMap_e1 );
    }
  }
  
  TBinaryMaster::SizeType strMapArr_size0 = (TBinaryMaster::SizeType)(p->strMapArr.size());
  mPushMaster.PushNum( strMapArr_size0 );
  for ( auto& strMapArr_e0 : p->strMapArr )
  {
    TBinaryMaster::SizeType strMapArr_size1 = (TBinaryMaster::SizeType)(strMapArr_e0.size());
    mPushMaster.PushNum( strMapArr_size1 );
    for ( auto& strMapArr_e1 : strMapArr_e0 )
    {
      mPushMaster.PushStr( strMapArr_e1.first );
      mPushMaster.PushStr( strMapArr_e1.second );
    }
  }
  
  TBinaryMaster::SizeType strMapMap_size0 = (TBinaryMaster::SizeType)(p->strMapMap.size());
  mPushMaster.PushNum( strMapMap_size0 );
  for ( auto& strMapMap_e0 : p->strMapMap )
  {
    TBinaryMaster::SizeType strMapMap_size1 = (TBinaryMaster::SizeType)(strMapMap_e0.second.size());
    mPushMaster.PushNum( strMapMap_size1 );
    mPushMaster.PushStr( strMapMap_e0.first );
    for ( auto& strMapMap_e1 : strMapMap_e0.second )
    {
      mPushMaster.PushStr( strMapMap_e1.first );
      mPushMaster.PushStr( strMapMap_e1.second );
    }
  }
  
  TBinaryMaster::SizeType objArrArr_size0 = (TBinaryMaster::SizeType)(p->objArrArr.size());
  mPushMaster.PushNum( objArrArr_size0 );
  for ( auto& objArrArr_e0 : p->objArrArr )
  {
    TBinaryMaster::SizeType objArrArr_size1 = (TBinaryMaster::SizeType)(objArrArr_e0.size());
    mPushMaster.PushNum( objArrArr_size1 );
    for ( auto& objArrArr_e1 : objArrArr_e0 )
    {
      bool objArrArr_isNotNull = &(objArrArr_e1) != nullptr;
      mPushMaster.PushBool( objArrArr_isNotNull );
      if ( objArrArr_isNotNull )
        _Serialize( &(objArrArr_e1) );
    }
  }
  
  TBinaryMaster::SizeType ptrObjArrArr_size0 = (TBinaryMaster::SizeType)(p->ptrObjArrArr.size());
  mPushMaster.PushNum( ptrObjArrArr_size0 );
  for ( auto& ptrObjArrArr_e0 : p->ptrObjArrArr )
  {
    TBinaryMaster::SizeType ptrObjArrArr_size1 = (TBinaryMaster::SizeType)(ptrObjArrArr_e0.size());
    mPushMaster.PushNum( ptrObjArrArr_size1 );
    for ( auto& ptrObjArrArr_e1 : ptrObjArrArr_e0 )
    {
      bool ptrObjArrArr_isNotNull = ptrObjArrArr_e1 != nullptr;
      mPushMaster.PushBool( ptrObjArrArr_isNotNull );
      if ( ptrObjArrArr_isNotNull )
        _Serialize( ptrObjArrArr_e1 );
    }
  }
  
  TBinaryMaster::SizeType spObjArrArr_size0 = (TBinaryMaster::SizeType)(p->spObjArrArr.size());
  mPushMaster.PushNum( spObjArrArr_size0 );
  for ( auto& spObjArrArr_e0 : p->spObjArrArr )
  {
    TBinaryMaster::SizeType spObjArrArr_size1 = (TBinaryMaster::SizeType)(spObjArrArr_e0.size());
    mPushMaster.PushNum( spObjArrArr_size1 );
    for ( auto& spObjArrArr_e1 : spObjArrArr_e0 )
    {
      bool spObjArrArr_isNotNull = spObjArrArr_e1.get() != nullptr;
      mPushMaster.PushBool( spObjArrArr_isNotNull );
      if ( spObjArrArr_isNotNull )
        _Serialize( spObjArrArr_e1.get() );
    }
  }
  
  TBinaryMaster::SizeType objMapArr_size0 = (TBinaryMaster::SizeType)(p->objMapArr.size());
  mPushMaster.PushNum( objMapArr_size0 );
  for ( auto& objMapArr_e0 : p->objMapArr )
  {
    TBinaryMaster::SizeType objMapArr_size1 = (TBinaryMaster::SizeType)(objMapArr_e0.size());
    mPushMaster.PushNum( objMapArr_size1 );
    for ( auto& objMapArr_e1 : objMapArr_e0 )
    {
      mPushMaster.PushStr( objMapArr_e1.first );
      bool objMapArr_isNotNull = &(objMapArr_e1.second) != nullptr;
      mPushMaster.PushBool( objMapArr_isNotNull );
      if ( objMapArr_isNotNull )
        _Serialize( &(objMapArr_e1.second) );
    }
  }
  
  TBinaryMaster::SizeType ptrObjMapArr_size0 = (TBinaryMaster::SizeType)(p->ptrObjMapArr.size());
  mPushMaster.PushNum( ptrObjMapArr_size0 );
  for ( auto& ptrObjMapArr_e0 : p->ptrObjMapArr )
  {
    TBinaryMaster::SizeType ptrObjMapArr_size1 = (TBinaryMaster::SizeType)(ptrObjMapArr_e0.size());
    mPushMaster.PushNum( ptrObjMapArr_size1 );
    for ( auto& ptrObjMapArr_e1 : ptrObjMapArr_e0 )
    {
      mPushMaster.PushStr( ptrObjMapArr_e1.first );
      bool ptrObjMapArr_isNotNull = ptrObjMapArr_e1.second != nullptr;
      mPushMaster.PushBool( ptrObjMapArr_isNotNull );
      if ( ptrObjMapArr_isNotNull )
        _Serialize( ptrObjMapArr_e1.second );
    }
  }
  
  TBinaryMaster::SizeType spObjMapArr_size0 = (TBinaryMaster::SizeType)(p->spObjMapArr.size());
  mPushMaster.PushNum( spObjMapArr_size0 );
  for ( auto& spObjMapArr_e0 : p->spObjMapArr )
  {
    TBinaryMaster::SizeType spObjMapArr_size1 = (TBinaryMaster::SizeType)(spObjMapArr_e0.size());
    mPushMaster.PushNum( spObjMapArr_size1 );
    for ( auto& spObjMapArr_e1 : spObjMapArr_e0 )
    {
      mPushMaster.PushStr( spObjMapArr_e1.first );
      bool spObjMapArr_isNotNull = spObjMapArr_e1.second.get() != nullptr;
      mPushMaster.PushBool( spObjMapArr_isNotNull );
      if ( spObjMapArr_isNotNull )
        _Serialize( spObjMapArr_e1.second.get() );
    }
  }
  
  TBinaryMaster::SizeType objMapMap_size0 = (TBinaryMaster::SizeType)(p->objMapMap.size());
  mPushMaster.PushNum( objMapMap_size0 );
  for ( auto& objMapMap_e0 : p->objMapMap )
  {
    TBinaryMaster::SizeType objMapMap_size1 = (TBinaryMaster::SizeType)(objMapMap_e0.second.size());
    mPushMaster.PushNum( objMapMap_size1 );
    mPushMaster.PushStr( objMapMap_e0.first );
    for ( auto& objMapMap_e1 : objMapMap_e0.second )
    {
      mPushMaster.PushStr( objMapMap_e1.first );
      bool objMapMap_isNotNull = &(objMapMap_e1.second) != nullptr;
      mPushMaster.PushBool( objMapMap_isNotNull );
      if ( objMapMap_isNotNull )
        _Serialize( &(objMapMap_e1.second) );
    }
  }
  
  TBinaryMaster::SizeType ptrObjMapMap_size0 = (TBinaryMaster::SizeType)(p->ptrObjMapMap.size());
  mPushMaster.PushNum( ptrObjMapMap_size0 );
  for ( auto& ptrObjMapMap_e0 : p->ptrObjMapMap )
  {
    TBinaryMaster::SizeType ptrObjMapMap_size1 = (TBinaryMaster::SizeType)(ptrObjMapMap_e0.second.size());
    mPushMaster.PushNum( ptrObjMapMap_size1 );
    mPushMaster.PushStr( ptrObjMapMap_e0.first );
    for ( auto& ptrObjMapMap_e1 : ptrObjMapMap_e0.second )
    {
      mPushMaster.PushStr( ptrObjMapMap_e1.first );
      bool ptrObjMapMap_isNotNull = ptrObjMapMap_e1.second != nullptr;
      mPushMaster.PushBool( ptrObjMapMap_isNotNull );
      if ( ptrObjMapMap_isNotNull )
        _Serialize( ptrObjMapMap_e1.second );
    }
  }
  
  TBinaryMaster::SizeType spObjMapMap_size0 = (TBinaryMaster::SizeType)(p->spObjMapMap.size());
  mPushMaster.PushNum( spObjMapMap_size0 );
  for ( auto& spObjMapMap_e0 : p->spObjMapMap )
  {
    TBinaryMaster::SizeType spObjMapMap_size1 = (TBinaryMaster::SizeType)(spObjMapMap_e0.second.size());
    mPushMaster.PushNum( spObjMapMap_size1 );
    mPushMaster.PushStr( spObjMapMap_e0.first );
    for ( auto& spObjMapMap_e1 : spObjMapMap_e0.second )
    {
      mPushMaster.PushStr( spObjMapMap_e1.first );
      bool spObjMapMap_isNotNull = spObjMapMap_e1.second.get() != nullptr;
      mPushMaster.PushBool( spObjMapMap_isNotNull );
      if ( spObjMapMap_isNotNull )
        _Serialize( spObjMapMap_e1.second.get() );
    }
  }
  
  TBinaryMaster::SizeType colossalMember_size0 = (TBinaryMaster::SizeType)(p->colossalMember.size());
  mPushMaster.PushNum( colossalMember_size0 );
  for ( auto& colossalMember_e0 : p->colossalMember )
  {
    TBinaryMaster::SizeType colossalMember_size1 = (TBinaryMaster::SizeType)(colossalMember_e0.second.size());
    mPushMaster.PushNum( colossalMember_size1 );
    mPushMaster.PushNum( colossalMember_e0.first );
    for ( auto& colossalMember_e1 : colossalMember_e0.second )
    {
      TBinaryMaster::SizeType colossalMember_size2 = (TBinaryMaster::SizeType)(colossalMember_e1.size());
      mPushMaster.PushNum( colossalMember_size2 );
      for ( auto& colossalMember_e2 : colossalMember_e1 )
      {
        TBinaryMaster::SizeType colossalMember_size3 = (TBinaryMaster::SizeType)(colossalMember_e2.second.size());
        mPushMaster.PushNum( colossalMember_size3 );
        mPushMaster.PushNum( colossalMember_e2.first );
        for ( auto& colossalMember_e3 : colossalMember_e2.second )
        {
          TBinaryMaster::SizeType colossalMember_size4 = (TBinaryMaster::SizeType)(colossalMember_e3.size());
          mPushMaster.PushNum( colossalMember_size4 );
          for ( auto& colossalMember_e4 : colossalMember_e3 )
          {
            TBinaryMaster::SizeType colossalMember_size5 = (TBinaryMaster::SizeType)(colossalMember_e4.second.size());
            mPushMaster.PushNum( colossalMember_size5 );
            mPushMaster.PushNum( colossalMember_e4.first );
            for ( auto& colossalMember_e5 : colossalMember_e4.second )
            {
              TBinaryMaster::SizeType colossalMember_size6 = (TBinaryMaster::SizeType)(colossalMember_e5.second.size());
              mPushMaster.PushNum( colossalMember_size6 );
              mPushMaster.PushNum( colossalMember_e5.first );
              for ( auto& colossalMember_e6 : colossalMember_e5.second )
              {
                TBinaryMaster::SizeType colossalMember_size7 = (TBinaryMaster::SizeType)(colossalMember_e6.size());
                mPushMaster.PushNum( colossalMember_size7 );
                for ( auto& colossalMember_e7 : colossalMember_e6 )
                {
                  mPushMaster.PushNum( colossalMember_e7 );
                }
              }
            }
          }
        }
      }
    }
  }
  
  TBinaryMaster::SizeType intSuperMap_size0 = (TBinaryMaster::SizeType)(p->intSuperMap.size());
  mPushMaster.PushNum( intSuperMap_size0 );
  for ( auto& intSuperMap_e0 : p->intSuperMap )
  {
    TBinaryMaster::SizeType intSuperMap_size1 = (TBinaryMaster::SizeType)(intSuperMap_e0.second.size());
    mPushMaster.PushNum( intSuperMap_size1 );
    mPushMaster.PushNum( intSuperMap_e0.first );
    for ( auto& intSuperMap_e1 : intSuperMap_e0.second )
    {
      TBinaryMaster::SizeType intSuperMap_size2 = (TBinaryMaster::SizeType)(intSuperMap_e1.second.size());
      mPushMaster.PushNum( intSuperMap_size2 );
      mPushMaster.PushNum( intSuperMap_e1.first );
      for ( auto& intSuperMap_e2 : intSuperMap_e1.second )
      {
        TBinaryMaster::SizeType intSuperMap_size3 = (TBinaryMaster::SizeType)(intSuperMap_e2.second.size());
        mPushMaster.PushNum( intSuperMap_size3 );
        mPushMaster.PushNum( intSuperMap_e2.first );
        for ( auto& intSuperMap_e3 : intSuperMap_e2.second )
        {
          mPushMaster.PushNum( intSuperMap_e3.first );
          mPushMaster.PushNum( intSuperMap_e3.second );
        }
      }
    }
  }
  
  TBinaryMaster::SizeType intSuperVec_size0 = (TBinaryMaster::SizeType)(p->intSuperVec.size());
  mPushMaster.PushNum( intSuperVec_size0 );
  for ( auto& intSuperVec_e0 : p->intSuperVec )
  {
    TBinaryMaster::SizeType intSuperVec_size1 = (TBinaryMaster::SizeType)(intSuperVec_e0.size());
    mPushMaster.PushNum( intSuperVec_size1 );
    for ( auto& intSuperVec_e1 : intSuperVec_e0 )
    {
      TBinaryMaster::SizeType intSuperVec_size2 = (TBinaryMaster::SizeType)(intSuperVec_e1.size());
      mPushMaster.PushNum( intSuperVec_size2 );
      for ( auto& intSuperVec_e2 : intSuperVec_e1 )
      {
        TBinaryMaster::SizeType intSuperVec_size3 = (TBinaryMaster::SizeType)(intSuperVec_e2.size());
        mPushMaster.PushNum( intSuperVec_size3 );
        for ( auto& intSuperVec_e3 : intSuperVec_e2 )
        {
          mPushMaster.PushNum( intSuperVec_e3 );
        }
      }
    }
  }
  
  TBinaryMaster::SizeType boolSuperList_size0 = (TBinaryMaster::SizeType)(p->boolSuperList.size());
  mPushMaster.PushNum( boolSuperList_size0 );
  for ( auto& boolSuperList_e0 : p->boolSuperList )
  {
    TBinaryMaster::SizeType boolSuperList_size1 = (TBinaryMaster::SizeType)(boolSuperList_e0.size());
    mPushMaster.PushNum( boolSuperList_size1 );
    for ( auto& boolSuperList_e1 : boolSuperList_e0 )
    {
      TBinaryMaster::SizeType boolSuperList_size2 = (TBinaryMaster::SizeType)(boolSuperList_e1.size());
      mPushMaster.PushNum( boolSuperList_size2 );
      for ( auto& boolSuperList_e2 : boolSuperList_e1 )
      {
        TBinaryMaster::SizeType boolSuperList_size3 = (TBinaryMaster::SizeType)(boolSuperList_e2.size());
        mPushMaster.PushNum( boolSuperList_size3 );
        for ( auto& boolSuperList_e3 : boolSuperList_e2 )
        {
          mPushMaster.PushBool( boolSuperList_e3 );
        }
      }
    }
  }
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsBS::TTestStruct* p )
{
  _Deserialize( (nsBS::TBaseStruct*)p );
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->baseStruct) );
  }
  if ( PopIsNotNullptr() )
  {
    if ( p->pBaseStruct == nullptr  )
      p->pBaseStruct = Allocate<nsBS::TBaseStruct>();
    _Deserialize( p->pBaseStruct );
  }
  else
  {
    Deallocate( p->pBaseStruct );
    p->pBaseStruct = nullptr;
  }
  if ( PopIsNotNullptr() )
  {
    if ( p->spBaseStruct.get() == nullptr  )
      p->spBaseStruct.reset( new nsBS::TBaseStruct() );
    _Deserialize( p->spBaseStruct.get() );
  }
  else
    p->spBaseStruct.reset();
  mPopMaster.PopStr( p->password );
  mPopMaster.PopNum( p->port );
  mPopMaster.PopBool( p->flag );
  mPopMaster.PopStrSet( p->strSet );
  mPopMaster.PopNumSet<int>( p->intSet );
  
  p->boolList.clear();
  TBinaryMaster::SizeType boolList_size0;
  mPopMaster.PopNum( boolList_size0 );
  for ( TBinaryMaster::SizeType boolList_i0 = 0 ; boolList_i0 < boolList_size0 ; boolList_i0++ ) 
  {
    bool boolList_key0;
    mPopMaster.PopBool( boolList_key0 );
    p->boolList.push_back( boolList_key0 );
  }
  
  p->numList.clear();
  TBinaryMaster::SizeType numList_size0;
  mPopMaster.PopNum( numList_size0 );
  for ( TBinaryMaster::SizeType numList_i0 = 0 ; numList_i0 < numList_size0 ; numList_i0++ ) 
  {
    int numList_key0;
    mPopMaster.PopNum( numList_key0 );
    p->numList.push_back( numList_key0 );
  }
  
  p->numVector.clear();
  TBinaryMaster::SizeType numVector_size0;
  mPopMaster.PopNum( numVector_size0 );
  for ( TBinaryMaster::SizeType numVector_i0 = 0 ; numVector_i0 < numVector_size0 ; numVector_i0++ ) 
  {
    int numVector_key0;
    mPopMaster.PopNum( numVector_key0 );
    p->numVector.push_back( numVector_key0 );
  }
  
  p->strVector.clear();
  TBinaryMaster::SizeType strVector_size0;
  mPopMaster.PopNum( strVector_size0 );
  for ( TBinaryMaster::SizeType strVector_i0 = 0 ; strVector_i0 < strVector_size0 ; strVector_i0++ ) 
  {
    std::string strVector_key0;
    mPopMaster.PopStr( strVector_key0 );
    p->strVector.push_back( strVector_key0 );
  }
  
  p->baseVec.clear();
  TBinaryMaster::SizeType baseVec_size0;
  mPopMaster.PopNum( baseVec_size0 );
  for ( TBinaryMaster::SizeType baseVec_i0 = 0 ; baseVec_i0 < baseVec_size0 ; baseVec_i0++ ) 
  {
    nsBS::TBaseStruct baseVec_e0;
    bool baseVec_IsNotNull;
    mPopMaster.PopBool( baseVec_IsNotNull );
    if ( baseVec_IsNotNull )
    {
      _Deserialize( &(baseVec_e0) );
    }
    p->baseVec.push_back( baseVec_e0 );
  }
  
  for ( auto& basePtrVec_e0 : p->basePtrVec )
  {
    Deallocate( basePtrVec_e0 );
  }
  p->basePtrVec.clear();
  TBinaryMaster::SizeType basePtrVec_size0;
  mPopMaster.PopNum( basePtrVec_size0 );
  for ( TBinaryMaster::SizeType basePtrVec_i0 = 0 ; basePtrVec_i0 < basePtrVec_size0 ; basePtrVec_i0++ ) 
  {
    nsBS::TBaseStruct* basePtrVec_e0 = nullptr;
    bool basePtrVec_IsNotNull;
    mPopMaster.PopBool( basePtrVec_IsNotNull );
    if ( basePtrVec_IsNotNull )
    {
      basePtrVec_e0 = Allocate<nsBS::TBaseStruct>();
      _Deserialize( basePtrVec_e0 );
    }
    p->basePtrVec.push_back( basePtrVec_e0 );
  }
  
  p->baseSPVec.clear();
  TBinaryMaster::SizeType baseSPVec_size0;
  mPopMaster.PopNum( baseSPVec_size0 );
  for ( TBinaryMaster::SizeType baseSPVec_i0 = 0 ; baseSPVec_i0 < baseSPVec_size0 ; baseSPVec_i0++ ) 
  {
    std::shared_ptr<nsBS::TBaseStruct> baseSPVec_e0;
    bool baseSPVec_IsNotNull;
    mPopMaster.PopBool( baseSPVec_IsNotNull );
    if ( baseSPVec_IsNotNull )
    {
      baseSPVec_e0.reset( new nsBS::TBaseStruct() );
      _Deserialize( baseSPVec_e0.get() );
    }
    p->baseSPVec.push_back( baseSPVec_e0 );
  }
  
  p->intIntMap.clear();
  TBinaryMaster::SizeType intIntMap_size0;
  mPopMaster.PopNum( intIntMap_size0 );
  for ( TBinaryMaster::SizeType intIntMap_i0 = 0 ; intIntMap_i0 < intIntMap_size0 ; intIntMap_i0++ ) 
  {
    int intIntMap_key0;
    mPopMaster.PopNum( intIntMap_key0 );
    int intIntMap_value0;
    mPopMaster.PopNum( intIntMap_value0 );
    p->intIntMap.insert( { intIntMap_key0, intIntMap_value0 } );
  }
  
  p->intBoolMap.clear();
  TBinaryMaster::SizeType intBoolMap_size0;
  mPopMaster.PopNum( intBoolMap_size0 );
  for ( TBinaryMaster::SizeType intBoolMap_i0 = 0 ; intBoolMap_i0 < intBoolMap_size0 ; intBoolMap_i0++ ) 
  {
    int intBoolMap_key0;
    mPopMaster.PopNum( intBoolMap_key0 );
    bool intBoolMap_value0;
    mPopMaster.PopBool( intBoolMap_value0 );
    p->intBoolMap.insert( { intBoolMap_key0, intBoolMap_value0 } );
  }
  
  p->intStrMap.clear();
  TBinaryMaster::SizeType intStrMap_size0;
  mPopMaster.PopNum( intStrMap_size0 );
  for ( TBinaryMaster::SizeType intStrMap_i0 = 0 ; intStrMap_i0 < intStrMap_size0 ; intStrMap_i0++ ) 
  {
    int intStrMap_key0;
    mPopMaster.PopNum( intStrMap_key0 );
    std::string intStrMap_value0;
    mPopMaster.PopStr( intStrMap_value0 );
    p->intStrMap.insert( { intStrMap_key0, intStrMap_value0 } );
  }
  
  p->strStrMap.clear();
  TBinaryMaster::SizeType strStrMap_size0;
  mPopMaster.PopNum( strStrMap_size0 );
  for ( TBinaryMaster::SizeType strStrMap_i0 = 0 ; strStrMap_i0 < strStrMap_size0 ; strStrMap_i0++ ) 
  {
    std::string strStrMap_key0;
    mPopMaster.PopStr( strStrMap_key0 );
    std::string strStrMap_value0;
    mPopMaster.PopStr( strStrMap_value0 );
    p->strStrMap.insert( { strStrMap_key0, strStrMap_value0 } );
  }
  
  p->strIntMap.clear();
  TBinaryMaster::SizeType strIntMap_size0;
  mPopMaster.PopNum( strIntMap_size0 );
  for ( TBinaryMaster::SizeType strIntMap_i0 = 0 ; strIntMap_i0 < strIntMap_size0 ; strIntMap_i0++ ) 
  {
    std::string strIntMap_key0;
    mPopMaster.PopStr( strIntMap_key0 );
    int strIntMap_value0;
    mPopMaster.PopNum( strIntMap_value0 );
    p->strIntMap.insert( { strIntMap_key0, strIntMap_value0 } );
  }
  
  p->strBoolMap.clear();
  TBinaryMaster::SizeType strBoolMap_size0;
  mPopMaster.PopNum( strBoolMap_size0 );
  for ( TBinaryMaster::SizeType strBoolMap_i0 = 0 ; strBoolMap_i0 < strBoolMap_size0 ; strBoolMap_i0++ ) 
  {
    std::string strBoolMap_key0;
    mPopMaster.PopStr( strBoolMap_key0 );
    bool strBoolMap_value0;
    mPopMaster.PopBool( strBoolMap_value0 );
    p->strBoolMap.insert( { strBoolMap_key0, strBoolMap_value0 } );
  }
  
  p->strBaseMap.clear();
  TBinaryMaster::SizeType strBaseMap_size0;
  mPopMaster.PopNum( strBaseMap_size0 );
  for ( TBinaryMaster::SizeType strBaseMap_i0 = 0 ; strBaseMap_i0 < strBaseMap_size0 ; strBaseMap_i0++ ) 
  {
    std::string strBaseMap_key0;
    mPopMaster.PopStr( strBaseMap_key0 );
    nsBS::TBaseStruct strBaseMap_e0;
    bool strBaseMap_IsNotNull;
    mPopMaster.PopBool( strBaseMap_IsNotNull );
    if ( strBaseMap_IsNotNull )
    {
      _Deserialize( &(strBaseMap_e0) );
    }
    p->strBaseMap.insert( { strBaseMap_key0, strBaseMap_e0 } );
  }
  
  for ( auto& strBasePtrMap_e0 : p->strBasePtrMap )
  {
    Deallocate( strBasePtrMap_e0.second );
  }
  p->strBasePtrMap.clear();
  TBinaryMaster::SizeType strBasePtrMap_size0;
  mPopMaster.PopNum( strBasePtrMap_size0 );
  for ( TBinaryMaster::SizeType strBasePtrMap_i0 = 0 ; strBasePtrMap_i0 < strBasePtrMap_size0 ; strBasePtrMap_i0++ ) 
  {
    std::string strBasePtrMap_key0;
    mPopMaster.PopStr( strBasePtrMap_key0 );
    nsBS::TBaseStruct* strBasePtrMap_e0 = nullptr;
    bool strBasePtrMap_IsNotNull;
    mPopMaster.PopBool( strBasePtrMap_IsNotNull );
    if ( strBasePtrMap_IsNotNull )
    {
      strBasePtrMap_e0 = Allocate<nsBS::TBaseStruct>();
      _Deserialize( strBasePtrMap_e0 );
    }
    p->strBasePtrMap.insert( { strBasePtrMap_key0, strBasePtrMap_e0 } );
  }
  
  p->strBaseSPMap.clear();
  TBinaryMaster::SizeType strBaseSPMap_size0;
  mPopMaster.PopNum( strBaseSPMap_size0 );
  for ( TBinaryMaster::SizeType strBaseSPMap_i0 = 0 ; strBaseSPMap_i0 < strBaseSPMap_size0 ; strBaseSPMap_i0++ ) 
  {
    std::string strBaseSPMap_key0;
    mPopMaster.PopStr( strBaseSPMap_key0 );
    std::shared_ptr<nsBS::TBaseStruct> strBaseSPMap_e0;
    bool strBaseSPMap_IsNotNull;
    mPopMaster.PopBool( strBaseSPMap_IsNotNull );
    if ( strBaseSPMap_IsNotNull )
    {
      strBaseSPMap_e0.reset( new nsBS::TBaseStruct() );
      _Deserialize( strBaseSPMap_e0.get() );
    }
    p->strBaseSPMap.insert( { strBaseSPMap_key0, strBaseSPMap_e0 } );
  }
  
  p->intBaseMap.clear();
  TBinaryMaster::SizeType intBaseMap_size0;
  mPopMaster.PopNum( intBaseMap_size0 );
  for ( TBinaryMaster::SizeType intBaseMap_i0 = 0 ; intBaseMap_i0 < intBaseMap_size0 ; intBaseMap_i0++ ) 
  {
    int intBaseMap_key0;
    mPopMaster.PopNum( intBaseMap_key0 );
    nsBS::TBaseStruct intBaseMap_e0;
    bool intBaseMap_IsNotNull;
    mPopMaster.PopBool( intBaseMap_IsNotNull );
    if ( intBaseMap_IsNotNull )
    {
      _Deserialize( &(intBaseMap_e0) );
    }
    p->intBaseMap.insert( { intBaseMap_key0, intBaseMap_e0 } );
  }
  
  for ( auto& intBasePtrMap_e0 : p->intBasePtrMap )
  {
    Deallocate( intBasePtrMap_e0.second );
  }
  p->intBasePtrMap.clear();
  TBinaryMaster::SizeType intBasePtrMap_size0;
  mPopMaster.PopNum( intBasePtrMap_size0 );
  for ( TBinaryMaster::SizeType intBasePtrMap_i0 = 0 ; intBasePtrMap_i0 < intBasePtrMap_size0 ; intBasePtrMap_i0++ ) 
  {
    int intBasePtrMap_key0;
    mPopMaster.PopNum( intBasePtrMap_key0 );
    nsBS::TBaseStruct* intBasePtrMap_e0 = nullptr;
    bool intBasePtrMap_IsNotNull;
    mPopMaster.PopBool( intBasePtrMap_IsNotNull );
    if ( intBasePtrMap_IsNotNull )
    {
      intBasePtrMap_e0 = Allocate<nsBS::TBaseStruct>();
      _Deserialize( intBasePtrMap_e0 );
    }
    p->intBasePtrMap.insert( { intBasePtrMap_key0, intBasePtrMap_e0 } );
  }
  
  p->intBaseSPMap.clear();
  TBinaryMaster::SizeType intBaseSPMap_size0;
  mPopMaster.PopNum( intBaseSPMap_size0 );
  for ( TBinaryMaster::SizeType intBaseSPMap_i0 = 0 ; intBaseSPMap_i0 < intBaseSPMap_size0 ; intBaseSPMap_i0++ ) 
  {
    int intBaseSPMap_key0;
    mPopMaster.PopNum( intBaseSPMap_key0 );
    std::shared_ptr<nsBS::TBaseStruct> intBaseSPMap_e0;
    bool intBaseSPMap_IsNotNull;
    mPopMaster.PopBool( intBaseSPMap_IsNotNull );
    if ( intBaseSPMap_IsNotNull )
    {
      intBaseSPMap_e0.reset( new nsBS::TBaseStruct() );
      _Deserialize( intBaseSPMap_e0.get() );
    }
    p->intBaseSPMap.insert( { intBaseSPMap_key0, intBaseSPMap_e0 } );
  }
  
  p->intArrArr.clear();
  TBinaryMaster::SizeType intArrArr_size0;
  mPopMaster.PopNum( intArrArr_size0 );
  for ( TBinaryMaster::SizeType intArrArr_i0 = 0 ; intArrArr_i0 < intArrArr_size0 ; intArrArr_i0++ ) 
  {
    TBinaryMaster::SizeType intArrArr_size1;
    mPopMaster.PopNum( intArrArr_size1 );
    std::vector<int> intArrArr_c0;
    for ( TBinaryMaster::SizeType intArrArr_i1 = 0 ; intArrArr_i1 < intArrArr_size1 ; intArrArr_i1++ ) 
    {
      int intArrArr_key1;
      mPopMaster.PopNum( intArrArr_key1 );
      intArrArr_c0.push_back( intArrArr_key1 );
    }
    p->intArrArr.push_back( intArrArr_c0 );
  }
  
  p->strArrArr.clear();
  TBinaryMaster::SizeType strArrArr_size0;
  mPopMaster.PopNum( strArrArr_size0 );
  for ( TBinaryMaster::SizeType strArrArr_i0 = 0 ; strArrArr_i0 < strArrArr_size0 ; strArrArr_i0++ ) 
  {
    TBinaryMaster::SizeType strArrArr_size1;
    mPopMaster.PopNum( strArrArr_size1 );
    std::vector<std::string> strArrArr_c0;
    for ( TBinaryMaster::SizeType strArrArr_i1 = 0 ; strArrArr_i1 < strArrArr_size1 ; strArrArr_i1++ ) 
    {
      std::string strArrArr_key1;
      mPopMaster.PopStr( strArrArr_key1 );
      strArrArr_c0.push_back( strArrArr_key1 );
    }
    p->strArrArr.push_back( strArrArr_c0 );
  }
  
  p->strArrMap.clear();
  TBinaryMaster::SizeType strArrMap_size0;
  mPopMaster.PopNum( strArrMap_size0 );
  for ( TBinaryMaster::SizeType strArrMap_i0 = 0 ; strArrMap_i0 < strArrMap_size0 ; strArrMap_i0++ ) 
  {
    TBinaryMaster::SizeType strArrMap_size1;
    mPopMaster.PopNum( strArrMap_size1 );
    std::string strArrMap_key0;
    mPopMaster.PopStr( strArrMap_key0 );
    std::vector<std::string> strArrMap_c0;
    for ( TBinaryMaster::SizeType strArrMap_i1 = 0 ; strArrMap_i1 < strArrMap_size1 ; strArrMap_i1++ ) 
    {
      std::string strArrMap_key1;
      mPopMaster.PopStr( strArrMap_key1 );
      strArrMap_c0.push_back( strArrMap_key1 );
    }
    p->strArrMap.insert( { strArrMap_key0, strArrMap_c0 } );
  }
  
  p->strMapArr.clear();
  TBinaryMaster::SizeType strMapArr_size0;
  mPopMaster.PopNum( strMapArr_size0 );
  for ( TBinaryMaster::SizeType strMapArr_i0 = 0 ; strMapArr_i0 < strMapArr_size0 ; strMapArr_i0++ ) 
  {
    TBinaryMaster::SizeType strMapArr_size1;
    mPopMaster.PopNum( strMapArr_size1 );
    std::map<std::string,std::string> strMapArr_c0;
    for ( TBinaryMaster::SizeType strMapArr_i1 = 0 ; strMapArr_i1 < strMapArr_size1 ; strMapArr_i1++ ) 
    {
      std::string strMapArr_key1;
      mPopMaster.PopStr( strMapArr_key1 );
      std::string strMapArr_value1;
      mPopMaster.PopStr( strMapArr_value1 );
      strMapArr_c0.insert( { strMapArr_key1, strMapArr_value1 } );
    }
    p->strMapArr.push_back( strMapArr_c0 );
  }
  
  p->strMapMap.clear();
  TBinaryMaster::SizeType strMapMap_size0;
  mPopMaster.PopNum( strMapMap_size0 );
  for ( TBinaryMaster::SizeType strMapMap_i0 = 0 ; strMapMap_i0 < strMapMap_size0 ; strMapMap_i0++ ) 
  {
    TBinaryMaster::SizeType strMapMap_size1;
    mPopMaster.PopNum( strMapMap_size1 );
    std::string strMapMap_key0;
    mPopMaster.PopStr( strMapMap_key0 );
    std::map<std::string,std::string> strMapMap_c0;
    for ( TBinaryMaster::SizeType strMapMap_i1 = 0 ; strMapMap_i1 < strMapMap_size1 ; strMapMap_i1++ ) 
    {
      std::string strMapMap_key1;
      mPopMaster.PopStr( strMapMap_key1 );
      std::string strMapMap_value1;
      mPopMaster.PopStr( strMapMap_value1 );
      strMapMap_c0.insert( { strMapMap_key1, strMapMap_value1 } );
    }
    p->strMapMap.insert( { strMapMap_key0, strMapMap_c0 } );
  }
  
  p->objArrArr.clear();
  TBinaryMaster::SizeType objArrArr_size0;
  mPopMaster.PopNum( objArrArr_size0 );
  for ( TBinaryMaster::SizeType objArrArr_i0 = 0 ; objArrArr_i0 < objArrArr_size0 ; objArrArr_i0++ ) 
  {
    TBinaryMaster::SizeType objArrArr_size1;
    mPopMaster.PopNum( objArrArr_size1 );
    std::vector<nsBS::TBaseStruct> objArrArr_c0;
    for ( TBinaryMaster::SizeType objArrArr_i1 = 0 ; objArrArr_i1 < objArrArr_size1 ; objArrArr_i1++ ) 
    {
      nsBS::TBaseStruct objArrArr_e1;
      bool objArrArr_IsNotNull;
      mPopMaster.PopBool( objArrArr_IsNotNull );
      if ( objArrArr_IsNotNull )
      {
        _Deserialize( &(objArrArr_e1) );
      }
      objArrArr_c0.push_back( objArrArr_e1 );
    }
    p->objArrArr.push_back( objArrArr_c0 );
  }
  
  for ( auto& ptrObjArrArr_e0 : p->ptrObjArrArr )
  {
    for ( auto& ptrObjArrArr_e1 : ptrObjArrArr_e0 )
    {
      Deallocate( ptrObjArrArr_e1 );
    }
  }
  p->ptrObjArrArr.clear();
  TBinaryMaster::SizeType ptrObjArrArr_size0;
  mPopMaster.PopNum( ptrObjArrArr_size0 );
  for ( TBinaryMaster::SizeType ptrObjArrArr_i0 = 0 ; ptrObjArrArr_i0 < ptrObjArrArr_size0 ; ptrObjArrArr_i0++ ) 
  {
    TBinaryMaster::SizeType ptrObjArrArr_size1;
    mPopMaster.PopNum( ptrObjArrArr_size1 );
    std::vector<nsBS::TBaseStruct*> ptrObjArrArr_c0;
    for ( TBinaryMaster::SizeType ptrObjArrArr_i1 = 0 ; ptrObjArrArr_i1 < ptrObjArrArr_size1 ; ptrObjArrArr_i1++ ) 
    {
      nsBS::TBaseStruct* ptrObjArrArr_e1 = nullptr;
      bool ptrObjArrArr_IsNotNull;
      mPopMaster.PopBool( ptrObjArrArr_IsNotNull );
      if ( ptrObjArrArr_IsNotNull )
      {
        ptrObjArrArr_e1 = Allocate<nsBS::TBaseStruct>();
        _Deserialize( ptrObjArrArr_e1 );
      }
      ptrObjArrArr_c0.push_back( ptrObjArrArr_e1 );
    }
    p->ptrObjArrArr.push_back( ptrObjArrArr_c0 );
  }
  
  p->spObjArrArr.clear();
  TBinaryMaster::SizeType spObjArrArr_size0;
  mPopMaster.PopNum( spObjArrArr_size0 );
  for ( TBinaryMaster::SizeType spObjArrArr_i0 = 0 ; spObjArrArr_i0 < spObjArrArr_size0 ; spObjArrArr_i0++ ) 
  {
    TBinaryMaster::SizeType spObjArrArr_size1;
    mPopMaster.PopNum( spObjArrArr_size1 );
    std::vector<std::shared_ptr<nsBS::TBaseStruct>> spObjArrArr_c0;
    for ( TBinaryMaster::SizeType spObjArrArr_i1 = 0 ; spObjArrArr_i1 < spObjArrArr_size1 ; spObjArrArr_i1++ ) 
    {
      std::shared_ptr<nsBS::TBaseStruct> spObjArrArr_e1;
      bool spObjArrArr_IsNotNull;
      mPopMaster.PopBool( spObjArrArr_IsNotNull );
      if ( spObjArrArr_IsNotNull )
      {
        spObjArrArr_e1.reset( new nsBS::TBaseStruct() );
        _Deserialize( spObjArrArr_e1.get() );
      }
      spObjArrArr_c0.push_back( spObjArrArr_e1 );
    }
    p->spObjArrArr.push_back( spObjArrArr_c0 );
  }
  
  p->objMapArr.clear();
  TBinaryMaster::SizeType objMapArr_size0;
  mPopMaster.PopNum( objMapArr_size0 );
  for ( TBinaryMaster::SizeType objMapArr_i0 = 0 ; objMapArr_i0 < objMapArr_size0 ; objMapArr_i0++ ) 
  {
    TBinaryMaster::SizeType objMapArr_size1;
    mPopMaster.PopNum( objMapArr_size1 );
    std::map<std::string,nsBS::TBaseStruct> objMapArr_c0;
    for ( TBinaryMaster::SizeType objMapArr_i1 = 0 ; objMapArr_i1 < objMapArr_size1 ; objMapArr_i1++ ) 
    {
      std::string objMapArr_key1;
      mPopMaster.PopStr( objMapArr_key1 );
      nsBS::TBaseStruct objMapArr_e1;
      bool objMapArr_IsNotNull;
      mPopMaster.PopBool( objMapArr_IsNotNull );
      if ( objMapArr_IsNotNull )
      {
        _Deserialize( &(objMapArr_e1) );
      }
      objMapArr_c0.insert( { objMapArr_key1, objMapArr_e1 } );
    }
    p->objMapArr.push_back( objMapArr_c0 );
  }
  
  for ( auto& ptrObjMapArr_e0 : p->ptrObjMapArr )
  {
    for ( auto& ptrObjMapArr_e1 : ptrObjMapArr_e0 )
    {
      Deallocate( ptrObjMapArr_e1.second );
    }
  }
  p->ptrObjMapArr.clear();
  TBinaryMaster::SizeType ptrObjMapArr_size0;
  mPopMaster.PopNum( ptrObjMapArr_size0 );
  for ( TBinaryMaster::SizeType ptrObjMapArr_i0 = 0 ; ptrObjMapArr_i0 < ptrObjMapArr_size0 ; ptrObjMapArr_i0++ ) 
  {
    TBinaryMaster::SizeType ptrObjMapArr_size1;
    mPopMaster.PopNum( ptrObjMapArr_size1 );
    std::map<std::string,nsBS::TBaseStruct*> ptrObjMapArr_c0;
    for ( TBinaryMaster::SizeType ptrObjMapArr_i1 = 0 ; ptrObjMapArr_i1 < ptrObjMapArr_size1 ; ptrObjMapArr_i1++ ) 
    {
      std::string ptrObjMapArr_key1;
      mPopMaster.PopStr( ptrObjMapArr_key1 );
      nsBS::TBaseStruct* ptrObjMapArr_e1 = nullptr;
      bool ptrObjMapArr_IsNotNull;
      mPopMaster.PopBool( ptrObjMapArr_IsNotNull );
      if ( ptrObjMapArr_IsNotNull )
      {
        ptrObjMapArr_e1 = Allocate<nsBS::TBaseStruct>();
        _Deserialize( ptrObjMapArr_e1 );
      }
      ptrObjMapArr_c0.insert( { ptrObjMapArr_key1, ptrObjMapArr_e1 } );
    }
    p->ptrObjMapArr.push_back( ptrObjMapArr_c0 );
  }
  
  p->spObjMapArr.clear();
  TBinaryMaster::SizeType spObjMapArr_size0;
  mPopMaster.PopNum( spObjMapArr_size0 );
  for ( TBinaryMaster::SizeType spObjMapArr_i0 = 0 ; spObjMapArr_i0 < spObjMapArr_size0 ; spObjMapArr_i0++ ) 
  {
    TBinaryMaster::SizeType spObjMapArr_size1;
    mPopMaster.PopNum( spObjMapArr_size1 );
    std::map<std::string,std::shared_ptr<nsBS::TBaseStruct>> spObjMapArr_c0;
    for ( TBinaryMaster::SizeType spObjMapArr_i1 = 0 ; spObjMapArr_i1 < spObjMapArr_size1 ; spObjMapArr_i1++ ) 
    {
      std::string spObjMapArr_key1;
      mPopMaster.PopStr( spObjMapArr_key1 );
      std::shared_ptr<nsBS::TBaseStruct> spObjMapArr_e1;
      bool spObjMapArr_IsNotNull;
      mPopMaster.PopBool( spObjMapArr_IsNotNull );
      if ( spObjMapArr_IsNotNull )
      {
        spObjMapArr_e1.reset( new nsBS::TBaseStruct() );
        _Deserialize( spObjMapArr_e1.get() );
      }
      spObjMapArr_c0.insert( { spObjMapArr_key1, spObjMapArr_e1 } );
    }
    p->spObjMapArr.push_back( spObjMapArr_c0 );
  }
  
  p->objMapMap.clear();
  TBinaryMaster::SizeType objMapMap_size0;
  mPopMaster.PopNum( objMapMap_size0 );
  for ( TBinaryMaster::SizeType objMapMap_i0 = 0 ; objMapMap_i0 < objMapMap_size0 ; objMapMap_i0++ ) 
  {
    TBinaryMaster::SizeType objMapMap_size1;
    mPopMaster.PopNum( objMapMap_size1 );
    std::string objMapMap_key0;
    mPopMaster.PopStr( objMapMap_key0 );
    std::map<std::string,nsBS::TBaseStruct> objMapMap_c0;
    for ( TBinaryMaster::SizeType objMapMap_i1 = 0 ; objMapMap_i1 < objMapMap_size1 ; objMapMap_i1++ ) 
    {
      std::string objMapMap_key1;
      mPopMaster.PopStr( objMapMap_key1 );
      nsBS::TBaseStruct objMapMap_e1;
      bool objMapMap_IsNotNull;
      mPopMaster.PopBool( objMapMap_IsNotNull );
      if ( objMapMap_IsNotNull )
      {
        _Deserialize( &(objMapMap_e1) );
      }
      objMapMap_c0.insert( { objMapMap_key1, objMapMap_e1 } );
    }
    p->objMapMap.insert( { objMapMap_key0, objMapMap_c0 } );
  }
  
  for ( auto& ptrObjMapMap_e0 : p->ptrObjMapMap )
  {
    for ( auto& ptrObjMapMap_e1 : ptrObjMapMap_e0.second )
    {
      Deallocate( ptrObjMapMap_e1.second );
    }
  }
  p->ptrObjMapMap.clear();
  TBinaryMaster::SizeType ptrObjMapMap_size0;
  mPopMaster.PopNum( ptrObjMapMap_size0 );
  for ( TBinaryMaster::SizeType ptrObjMapMap_i0 = 0 ; ptrObjMapMap_i0 < ptrObjMapMap_size0 ; ptrObjMapMap_i0++ ) 
  {
    TBinaryMaster::SizeType ptrObjMapMap_size1;
    mPopMaster.PopNum( ptrObjMapMap_size1 );
    std::string ptrObjMapMap_key0;
    mPopMaster.PopStr( ptrObjMapMap_key0 );
    std::map<std::string,nsBS::TBaseStruct*> ptrObjMapMap_c0;
    for ( TBinaryMaster::SizeType ptrObjMapMap_i1 = 0 ; ptrObjMapMap_i1 < ptrObjMapMap_size1 ; ptrObjMapMap_i1++ ) 
    {
      std::string ptrObjMapMap_key1;
      mPopMaster.PopStr( ptrObjMapMap_key1 );
      nsBS::TBaseStruct* ptrObjMapMap_e1 = nullptr;
      bool ptrObjMapMap_IsNotNull;
      mPopMaster.PopBool( ptrObjMapMap_IsNotNull );
      if ( ptrObjMapMap_IsNotNull )
      {
        ptrObjMapMap_e1 = Allocate<nsBS::TBaseStruct>();
        _Deserialize( ptrObjMapMap_e1 );
      }
      ptrObjMapMap_c0.insert( { ptrObjMapMap_key1, ptrObjMapMap_e1 } );
    }
    p->ptrObjMapMap.insert( { ptrObjMapMap_key0, ptrObjMapMap_c0 } );
  }
  
  p->spObjMapMap.clear();
  TBinaryMaster::SizeType spObjMapMap_size0;
  mPopMaster.PopNum( spObjMapMap_size0 );
  for ( TBinaryMaster::SizeType spObjMapMap_i0 = 0 ; spObjMapMap_i0 < spObjMapMap_size0 ; spObjMapMap_i0++ ) 
  {
    TBinaryMaster::SizeType spObjMapMap_size1;
    mPopMaster.PopNum( spObjMapMap_size1 );
    std::string spObjMapMap_key0;
    mPopMaster.PopStr( spObjMapMap_key0 );
    std::map<std::string,std::shared_ptr<nsBS::TBaseStruct>> spObjMapMap_c0;
    for ( TBinaryMaster::SizeType spObjMapMap_i1 = 0 ; spObjMapMap_i1 < spObjMapMap_size1 ; spObjMapMap_i1++ ) 
    {
      std::string spObjMapMap_key1;
      mPopMaster.PopStr( spObjMapMap_key1 );
      std::shared_ptr<nsBS::TBaseStruct> spObjMapMap_e1;
      bool spObjMapMap_IsNotNull;
      mPopMaster.PopBool( spObjMapMap_IsNotNull );
      if ( spObjMapMap_IsNotNull )
      {
        spObjMapMap_e1.reset( new nsBS::TBaseStruct() );
        _Deserialize( spObjMapMap_e1.get() );
      }
      spObjMapMap_c0.insert( { spObjMapMap_key1, spObjMapMap_e1 } );
    }
    p->spObjMapMap.insert( { spObjMapMap_key0, spObjMapMap_c0 } );
  }
  
  p->colossalMember.clear();
  TBinaryMaster::SizeType colossalMember_size0;
  mPopMaster.PopNum( colossalMember_size0 );
  for ( TBinaryMaster::SizeType colossalMember_i0 = 0 ; colossalMember_i0 < colossalMember_size0 ; colossalMember_i0++ ) 
  {
    TBinaryMaster::SizeType colossalMember_size1;
    mPopMaster.PopNum( colossalMember_size1 );
    int colossalMember_key0;
    mPopMaster.PopNum( colossalMember_key0 );
    std::vector<std::map<int,std::vector<std::map<int,std::map<int,std::vector<std::vector<int>>>>>>> colossalMember_c0;
    for ( TBinaryMaster::SizeType colossalMember_i1 = 0 ; colossalMember_i1 < colossalMember_size1 ; colossalMember_i1++ ) 
    {
      TBinaryMaster::SizeType colossalMember_size2;
      mPopMaster.PopNum( colossalMember_size2 );
      std::map<int,std::vector<std::map<int,std::map<int,std::vector<std::vector<int>>>>>> colossalMember_c1;
      for ( TBinaryMaster::SizeType colossalMember_i2 = 0 ; colossalMember_i2 < colossalMember_size2 ; colossalMember_i2++ ) 
      {
        TBinaryMaster::SizeType colossalMember_size3;
        mPopMaster.PopNum( colossalMember_size3 );
        int colossalMember_key2;
        mPopMaster.PopNum( colossalMember_key2 );
        std::vector<std::map<int,std::map<int,std::vector<std::vector<int>>>>> colossalMember_c2;
        for ( TBinaryMaster::SizeType colossalMember_i3 = 0 ; colossalMember_i3 < colossalMember_size3 ; colossalMember_i3++ ) 
        {
          TBinaryMaster::SizeType colossalMember_size4;
          mPopMaster.PopNum( colossalMember_size4 );
          std::map<int,std::map<int,std::vector<std::vector<int>>>> colossalMember_c3;
          for ( TBinaryMaster::SizeType colossalMember_i4 = 0 ; colossalMember_i4 < colossalMember_size4 ; colossalMember_i4++ ) 
          {
            TBinaryMaster::SizeType colossalMember_size5;
            mPopMaster.PopNum( colossalMember_size5 );
            int colossalMember_key4;
            mPopMaster.PopNum( colossalMember_key4 );
            std::map<int,std::vector<std::vector<int>>> colossalMember_c4;
            for ( TBinaryMaster::SizeType colossalMember_i5 = 0 ; colossalMember_i5 < colossalMember_size5 ; colossalMember_i5++ ) 
            {
              TBinaryMaster::SizeType colossalMember_size6;
              mPopMaster.PopNum( colossalMember_size6 );
              int colossalMember_key5;
              mPopMaster.PopNum( colossalMember_key5 );
              std::vector<std::vector<int>> colossalMember_c5;
              for ( TBinaryMaster::SizeType colossalMember_i6 = 0 ; colossalMember_i6 < colossalMember_size6 ; colossalMember_i6++ ) 
              {
                TBinaryMaster::SizeType colossalMember_size7;
                mPopMaster.PopNum( colossalMember_size7 );
                std::vector<int> colossalMember_c6;
                for ( TBinaryMaster::SizeType colossalMember_i7 = 0 ; colossalMember_i7 < colossalMember_size7 ; colossalMember_i7++ ) 
                {
                  int colossalMember_key7;
                  mPopMaster.PopNum( colossalMember_key7 );
                  colossalMember_c6.push_back( colossalMember_key7 );
                }
                colossalMember_c5.push_back( colossalMember_c6 );
              }
              colossalMember_c4.insert( { colossalMember_key5, colossalMember_c5 } );
            }
            colossalMember_c3.insert( { colossalMember_key4, colossalMember_c4 } );
          }
          colossalMember_c2.push_back( colossalMember_c3 );
        }
        colossalMember_c1.insert( { colossalMember_key2, colossalMember_c2 } );
      }
      colossalMember_c0.push_back( colossalMember_c1 );
    }
    p->colossalMember.insert( { colossalMember_key0, colossalMember_c0 } );
  }
  
  p->intSuperMap.clear();
  TBinaryMaster::SizeType intSuperMap_size0;
  mPopMaster.PopNum( intSuperMap_size0 );
  for ( TBinaryMaster::SizeType intSuperMap_i0 = 0 ; intSuperMap_i0 < intSuperMap_size0 ; intSuperMap_i0++ ) 
  {
    TBinaryMaster::SizeType intSuperMap_size1;
    mPopMaster.PopNum( intSuperMap_size1 );
    int intSuperMap_key0;
    mPopMaster.PopNum( intSuperMap_key0 );
    std::map<int,std::map<int,std::map<int,int>>> intSuperMap_c0;
    for ( TBinaryMaster::SizeType intSuperMap_i1 = 0 ; intSuperMap_i1 < intSuperMap_size1 ; intSuperMap_i1++ ) 
    {
      TBinaryMaster::SizeType intSuperMap_size2;
      mPopMaster.PopNum( intSuperMap_size2 );
      int intSuperMap_key1;
      mPopMaster.PopNum( intSuperMap_key1 );
      std::map<int,std::map<int,int>> intSuperMap_c1;
      for ( TBinaryMaster::SizeType intSuperMap_i2 = 0 ; intSuperMap_i2 < intSuperMap_size2 ; intSuperMap_i2++ ) 
      {
        TBinaryMaster::SizeType intSuperMap_size3;
        mPopMaster.PopNum( intSuperMap_size3 );
        int intSuperMap_key2;
        mPopMaster.PopNum( intSuperMap_key2 );
        std::map<int,int> intSuperMap_c2;
        for ( TBinaryMaster::SizeType intSuperMap_i3 = 0 ; intSuperMap_i3 < intSuperMap_size3 ; intSuperMap_i3++ ) 
        {
          int intSuperMap_key3;
          mPopMaster.PopNum( intSuperMap_key3 );
          int intSuperMap_value3;
          mPopMaster.PopNum( intSuperMap_value3 );
          intSuperMap_c2.insert( { intSuperMap_key3, intSuperMap_value3 } );
        }
        intSuperMap_c1.insert( { intSuperMap_key2, intSuperMap_c2 } );
      }
      intSuperMap_c0.insert( { intSuperMap_key1, intSuperMap_c1 } );
    }
    p->intSuperMap.insert( { intSuperMap_key0, intSuperMap_c0 } );
  }
  
  p->intSuperVec.clear();
  TBinaryMaster::SizeType intSuperVec_size0;
  mPopMaster.PopNum( intSuperVec_size0 );
  for ( TBinaryMaster::SizeType intSuperVec_i0 = 0 ; intSuperVec_i0 < intSuperVec_size0 ; intSuperVec_i0++ ) 
  {
    TBinaryMaster::SizeType intSuperVec_size1;
    mPopMaster.PopNum( intSuperVec_size1 );
    std::vector<std::vector<std::vector<int>>> intSuperVec_c0;
    for ( TBinaryMaster::SizeType intSuperVec_i1 = 0 ; intSuperVec_i1 < intSuperVec_size1 ; intSuperVec_i1++ ) 
    {
      TBinaryMaster::SizeType intSuperVec_size2;
      mPopMaster.PopNum( intSuperVec_size2 );
      std::vector<std::vector<int>> intSuperVec_c1;
      for ( TBinaryMaster::SizeType intSuperVec_i2 = 0 ; intSuperVec_i2 < intSuperVec_size2 ; intSuperVec_i2++ ) 
      {
        TBinaryMaster::SizeType intSuperVec_size3;
        mPopMaster.PopNum( intSuperVec_size3 );
        std::vector<int> intSuperVec_c2;
        for ( TBinaryMaster::SizeType intSuperVec_i3 = 0 ; intSuperVec_i3 < intSuperVec_size3 ; intSuperVec_i3++ ) 
        {
          int intSuperVec_key3;
          mPopMaster.PopNum( intSuperVec_key3 );
          intSuperVec_c2.push_back( intSuperVec_key3 );
        }
        intSuperVec_c1.push_back( intSuperVec_c2 );
      }
      intSuperVec_c0.push_back( intSuperVec_c1 );
    }
    p->intSuperVec.push_back( intSuperVec_c0 );
  }
  
  p->boolSuperList.clear();
  TBinaryMaster::SizeType boolSuperList_size0;
  mPopMaster.PopNum( boolSuperList_size0 );
  for ( TBinaryMaster::SizeType boolSuperList_i0 = 0 ; boolSuperList_i0 < boolSuperList_size0 ; boolSuperList_i0++ ) 
  {
    TBinaryMaster::SizeType boolSuperList_size1;
    mPopMaster.PopNum( boolSuperList_size1 );
    std::list<std::list<std::list<bool>>> boolSuperList_c0;
    for ( TBinaryMaster::SizeType boolSuperList_i1 = 0 ; boolSuperList_i1 < boolSuperList_size1 ; boolSuperList_i1++ ) 
    {
      TBinaryMaster::SizeType boolSuperList_size2;
      mPopMaster.PopNum( boolSuperList_size2 );
      std::list<std::list<bool>> boolSuperList_c1;
      for ( TBinaryMaster::SizeType boolSuperList_i2 = 0 ; boolSuperList_i2 < boolSuperList_size2 ; boolSuperList_i2++ ) 
      {
        TBinaryMaster::SizeType boolSuperList_size3;
        mPopMaster.PopNum( boolSuperList_size3 );
        std::list<bool> boolSuperList_c2;
        for ( TBinaryMaster::SizeType boolSuperList_i3 = 0 ; boolSuperList_i3 < boolSuperList_size3 ; boolSuperList_i3++ ) 
        {
          bool boolSuperList_key3;
          mPopMaster.PopBool( boolSuperList_key3 );
          boolSuperList_c2.push_back( boolSuperList_key3 );
        }
        boolSuperList_c1.push_back( boolSuperList_c2 );
      }
      boolSuperList_c0.push_back( boolSuperList_c1 );
    }
    p->boolSuperList.push_back( boolSuperList_c0 );
  }
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsBS::TTestStruct* p )
{
  return e_nsBS_TTestStruct;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deallocate( nsBS::TTestStruct* p )
{
  _Deallocate( p->pBaseStruct );
  p->pBaseStruct = nullptr;
  p->spBaseStruct.reset();
  p->boolList.clear();
  p->numList.clear();
  p->numVector.clear();
  p->strVector.clear();
  p->baseVec.clear();
  for ( auto& basePtrVec_e0 : p->basePtrVec )
  {
    Deallocate( basePtrVec_e0 );
  }
  p->basePtrVec.clear();
  p->baseSPVec.clear();
  p->intIntMap.clear();
  p->intBoolMap.clear();
  p->intStrMap.clear();
  p->strStrMap.clear();
  p->strIntMap.clear();
  p->strBoolMap.clear();
  p->strBaseMap.clear();
  for ( auto& strBasePtrMap_e0 : p->strBasePtrMap )
  {
    Deallocate( strBasePtrMap_e0.second );
  }
  p->strBasePtrMap.clear();
  p->strBaseSPMap.clear();
  p->intBaseMap.clear();
  for ( auto& intBasePtrMap_e0 : p->intBasePtrMap )
  {
    Deallocate( intBasePtrMap_e0.second );
  }
  p->intBasePtrMap.clear();
  p->intBaseSPMap.clear();
  p->intArrArr.clear();
  p->strArrArr.clear();
  p->strArrMap.clear();
  p->strMapArr.clear();
  p->strMapMap.clear();
  p->objArrArr.clear();
  for ( auto& ptrObjArrArr_e0 : p->ptrObjArrArr )
  {
    for ( auto& ptrObjArrArr_e1 : ptrObjArrArr_e0 )
    {
      Deallocate( ptrObjArrArr_e1 );
    }
  }
  p->ptrObjArrArr.clear();
  p->spObjArrArr.clear();
  p->objMapArr.clear();
  for ( auto& ptrObjMapArr_e0 : p->ptrObjMapArr )
  {
    for ( auto& ptrObjMapArr_e1 : ptrObjMapArr_e0 )
    {
      Deallocate( ptrObjMapArr_e1.second );
    }
  }
  p->ptrObjMapArr.clear();
  p->spObjMapArr.clear();
  p->objMapMap.clear();
  for ( auto& ptrObjMapMap_e0 : p->ptrObjMapMap )
  {
    for ( auto& ptrObjMapMap_e1 : ptrObjMapMap_e0.second )
    {
      Deallocate( ptrObjMapMap_e1.second );
    }
  }
  p->ptrObjMapMap.clear();
  p->spObjMapMap.clear();
  p->colossalMember.clear();
  p->intSuperMap.clear();
  p->intSuperVec.clear();
  p->boolSuperList.clear();
}
//---------------------------------------------------------------------------------------
