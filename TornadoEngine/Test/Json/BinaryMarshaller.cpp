/*
Author: Gudakov Ramil Sergeevich a.k.a.Gauss
Гудаков Рамиль Сергеевич
Contacts : [ramil2085@mail.ru, ramil2085@gmail.com]
See for more information License.h.
*/
// File has been generated by ReflectionCodeGenerator version 1.0 build 22, at 2019_01_27 12:40:25.161
	
#include "BinaryMarshaller.h"
#include "UnpackHandler.h"

using namespace nsBinary;

void TBinaryMarshaller::SetLimitForCompression( int binarySize )
{
  mSetLimitForCompression = binarySize;
}
//-----------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::GetID( char* packedData, int size )
{
  auto pHeader = (THeader*) packedData;
  return pHeader->type;
}
//-----------------------------------------------------------------------------
void TBinaryMarshaller::PushIsNotNullptr( void* p )
{
  unsigned char isNullptr = p == nullptr ? 0 : 1;
  mPushMaster.PushNum( isNullptr );
}
//-----------------------------------------------------------------------------
bool TBinaryMarshaller::PopIsNotNullptr()
{
  unsigned char isNullptr;
  mPopMaster.PopNum( isNullptr );
  return ( isNullptr != 0 );
}
//-----------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::PrepareForUnpackPopMaster( char* packedData, int size )
{
  int headerSize = sizeof( THeader );
  THeader header;
  memcpy( &header, packedData, headerSize );
  char* pObj = packedData + headerSize;
  int objSize = size - headerSize;

  // decompression
  if ( header.useCompression )
  {
    mBuffer.Clear();
    mBuffer.Shift( objSize * header.ratio );// расширить для запаса под декомпрессию
    int decompressedRes = LZ4_decompress_safe( pObj, mBuffer.GetPtr(), objSize, mBuffer.GetSize() );
    mBuffer.Clear();
    mBuffer.Shift( decompressedRes );
  }
  else
  {
    mBuffer.Clear();
    mBuffer.Append( objSize, pObj );
  }
  mPopMaster.SetBuffer( &mBuffer, 0 );
  return header.type;
}
//-----------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::Unpack( char* packedData, int size )
{
  auto type = PrepareForUnpackPopMaster( packedData, size );
  switch( type )
  {
    case e_TBaseStruct:
    {
      auto p = Allocate<TBaseStruct>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TTestClass:
    {
      auto p = Allocate<TTestClass>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TTestStruct:
    {
      auto p = Allocate<TTestStruct>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
  }
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TBaseStruct* p )
{
  mPushMaster.PushStr( p->s );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TBaseStruct* p )
{
  mPopMaster.PopStr( p->s );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TBaseStruct* p )
{
  return e_TBaseStruct;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TTestClass* p )
{
  auto ts_p = &(p->ts);
  PushIsNotNullptr( ts_p );
  if ( ts_p )
    _Serialize( ts_p );
  mPushMaster.PushStr( p->str );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TTestClass* p )
{
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->ts) );
  }
  mPopMaster.PopStr( p->str );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TTestClass* p )
{
  return e_TTestClass;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TTestStruct* p )
{
  _Serialize( (TBaseStruct*)p );
  mPushMaster.PushStr( p->password );
  mPushMaster.PushNum( p->port );
  mPushMaster.PushBool( p->flag );
  mPushMaster.PushNumArray<int>( p->numList );
  mPushMaster.PushStrArray( p->strSet );
  mPushMaster.PushNumArray<int>( p->numVector );
  mPushMaster.PushNumArray<int>( p->intSet );
  mPushMaster.PushNumStrMap<int>( p->intStrMap );
  mPushMaster.PushStrStrMap( p->strStrMap );
  mPushMaster.PushStrNumMap<int>( p->strIntMap );
  mPushMaster.PushStrBoolMap( p->strBoolMap );
  mPushMaster.PushSerObjArray<TBaseStruct>( p->baseVec, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushSerPtrArray<TBaseStruct>( p->basePtrVec, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushSerSmartPtrArray<TBaseStruct, std::shared_ptr<TBaseStruct>>( p->baseSPVec, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushStrSerObjMap<TBaseStruct>( p->strBaseMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushStrSerPtrMap<TBaseStruct>( p->strBasePtrMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushStrSerSmartPtrMap<TBaseStruct, std::shared_ptr<TBaseStruct>>( p->strBaseSPMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumSerObjMap<int, TBaseStruct>( p->intBaseMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumSerPtrMap<int, TBaseStruct>( p->intBasePtrMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumSerSmartPtrMap<int, TBaseStruct, std::shared_ptr<TBaseStruct>>( p->intBaseSPMap, [this]( TBaseStruct* p ) { _Serialize( p ); } );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TTestStruct* p )
{
  _Deserialize( (TBaseStruct*)p );
  mPopMaster.PopStr( p->password );
  mPopMaster.PopNum( p->port );
  mPopMaster.PopBool( p->flag );
  mPopMaster.PopNumArray<int>( p->numList );
  mPopMaster.PopStrSet( p->strSet );
  mPopMaster.PopNumArray<int>( p->numVector );
  mPopMaster.PopNumSet( p->intSet );
  mPopMaster.PopNumStrMap<int>( p->intStrMap );
  mPopMaster.PopStrStrMap( p->strStrMap );
  mPopMaster.PopStrNumMap<int>( p->strIntMap );
  mPopMaster.PopStrBoolMap( p->strBoolMap );
  mPopMaster.PopSerObjArray<TBaseStruct>( p->baseVec, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopSerPtrArray<TBaseStruct>( p->basePtrVec, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopSerSmartPtrArray<TBaseStruct, std::shared_ptr<TBaseStruct>>( p->baseSPVec, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopStrSerObjMap<TBaseStruct>( p->strBaseMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopStrSerPtrMap<TBaseStruct>( p->strBasePtrMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopStrSerSmartPtrMap<TBaseStruct, std::shared_ptr<TBaseStruct>>( p->strBaseSPMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumSerObjMap<int, TBaseStruct>( p->intBaseMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumSerPtrMap<int, TBaseStruct>( p->intBasePtrMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumSerSmartPtrMap<int, TBaseStruct, std::shared_ptr<TBaseStruct>>( p->intBaseSPMap, [this]( TBaseStruct* p ) { _Deserialize( p ); } );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TTestStruct* p )
{
  return e_TTestStruct;
}
//---------------------------------------------------------------------------------------
