/*
	ReflectionCodeGenerator
*/
// File has been generated by ReflectionCodeGenerator version 1.18 build 46, at 2020_10_02 11:53:37.148
	
#pragma once

#include <list>
#include <string>
#include <functional>
#include "JsonMaster.h"
#include "IncludeList.h"

class TGameEngineJsonSerializer
{
    typedef TJsonMaster::Jobj Jobj;
    typedef TJsonMaster::Jarr Jarr;

    struct TypeFunc
    {
        std::function<void(void*, std::string&)>  serializeFunc;
        std::function<bool(void*&, const std::string&, std::string&)> deserializeFunc;
        std::function<bool(void*, const std::string&, std::string&)> fillFunc;
    };

    static std::map<std::string, TypeFunc> mTypeNameFuncsMap;
    static std::list<std::string> mTypeNameList;

    static void Init();
public:
    static const std::list<std::string>& GetTypeNameList();

    template <typename Type>
    static void Serialize(Type* p, std::string& str);
    template <typename Type>
    static bool Deserialize(Type*& p, const std::string& str, std::string& err);
    template <typename Type>
    static bool Fill(Type* p, const std::string& str, std::string& err);

    static void Serialize(void* p, std::string& str, const std::string& typeName);
    static bool Deserialize(void*& p, const std::string& str, const std::string& typeName, std::string& err);
    static bool Fill(void* p, const std::string& str, const std::string& typeName, std::string& err);
private:
    template <typename Type>
    static bool _Deserialize(Type*& p, const std::string& str, bool checkPtr, std::string& err);
private:
    static void _Serialize( TAppConfig* p, Jobj& obj );
    static void _Deserialize( TAppConfig* p, const Jobj& obj );
    
    static void _Serialize( TConveyerConfig* p, Jobj& obj );
    static void _Deserialize( TConveyerConfig* p, const Jobj& obj );
    
};
//------------------------------------------------------------------------------------------------------------
template <typename Type>
static void TGameEngineJsonSerializer::Serialize(Type* p, std::string& str)
{
    rapidjson::Document doc(rapidjson::Type::kObjectType);
    auto obj = doc.GetObject();

    _Serialize(p, obj);

    rapidjson::StringBuffer sb;
    rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(sb);
    doc.Accept(writer);
    str = sb.GetString();
}
//------------------------------------------------------------------------------------------------------------
template <typename Type>
static bool TGameEngineJsonSerializer::Deserialize(Type*& p, const std::string& str, std::string& err)
{
    return _Deserialize(p, str, true, err);
}
//------------------------------------------------------------------------------------------------------------
template <typename Type>
static bool TGameEngineJsonSerializer::Fill(Type* p, const std::string& str, std::string& err)
{
    return _Deserialize(p, str, false, err);
}
//------------------------------------------------------------------------------------------------------------
template <typename Type>
static bool TGameEngineJsonSerializer::_Deserialize(Type*& p, const std::string& str, bool checkPtr, std::string& err)
{
    rapidjson::Document doc(rapidjson::Type::kObjectType);
    const auto parseFlags = rapidjson::ParseFlag::kParseFullPrecisionFlag | rapidjson::ParseFlag::kParseCommentsFlag | rapidjson::ParseFlag::kParseTrailingCommasFlag;
    rapidjson::ParseResult ok = doc.Parse<parseFlags>(str.data());
    if ( !ok ) {
        auto errStr = GetParseError_En(ok.Code());
        err = "JSON parse error : " + std::string(errStr) + ", line " + std::to_string(ok.Offset()) + "\n";
        return false;
    }

    if ( checkPtr ) {
        p = p ? p : new Type();
    }

    try{
        auto obj = doc.GetObject();
        _Deserialize( p, obj );
    } catch( std::exception& ex ) {
        err = ex.what();
        return false;
    }
    return true;
}
