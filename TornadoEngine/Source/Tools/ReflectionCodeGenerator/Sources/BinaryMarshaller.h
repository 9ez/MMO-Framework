/*
	ReflectionCodeGenerator
*/
// File has been generated by ReflectionCodeGenerator version 1.14 build 42, at 2020_09_13 14:04:07.830
	
#pragma once

#include <functional>
#include "ContainerRise.h"
#include "TypeDef.h"
#include "BinaryPushMaster.h"
#include "BinaryPopMaster.h"
#include "MemoryObjectPoolAllocator.h"
#include "lz4.h"
#include "BL_Debug.h"

#include "IncludeList.h"

namespace nsBinary
{
    class TBinaryMarshaller
    {
    public:
      typedef unsigned short TypeID;
    private:
    #ifdef WIN32
    #pragma pack(push, 1)
    #endif
      struct THeader
      {
        TypeID type : 15;
        TypeID useCompression : 1;
        unsigned char ratio = 0;
      }_PACKED;
    #ifdef WIN32
    #pragma pack(pop)
    #endif
      // upper use LZ4 for compression
      int mSetLimitForCompression = 0x40;
    
      TContainerRise mBuffer;
      // collectors
      TBinaryPushMaster mPushMaster;
      TBinaryPopMaster mPopMaster;
    public:
      enum SerializableUniqueID : TypeID
      {
            e_TFloat3 = 666,
            e_TFloat4,
            e_TParamClass,
            e_TTestClass,
            e_nsBS_TBaseStruct,
            e_nsBS_TTestStruct,
            e_nsMathTools_TMatrix16,
            e_nsMathTools_TMatrix9,
            e_nsMathTools_TOrientation,
            e_nsMathTools_TPlane,
            e_nsMathTools_TPoint2,
            e_nsMathTools_TQuaternion,
            e_nsMathTools_TVector2,
            e_nsMathTools_TVector3,
            e_nsMathTools_TVector4,
            e_nsReflectionCodeGenerator_TBinaryMarshallerGeneratorConfig,
            e_nsReflectionCodeGenerator_TClassDesc,
            e_nsReflectionCodeGenerator_TConfig,
            e_nsReflectionCodeGenerator_TFilter,
            e_nsReflectionCodeGenerator_TImplementation,
            e_nsReflectionCodeGenerator_TJsonSerializerGeneratorConfig,
            e_nsReflectionCodeGenerator_TSqlGeneratorConfig,
            e_nsReflectionCodeGenerator_TTargetForCodeGeneration,
            e_nsReflectionCodeGenerator_TTargetForParsing,
            e_nsReflectionCodeGenerator_TUnpackHandler,
      };
    
      void SetLimitForCompression( int binarySize );
    
      // serialize / deserialize
      template <typename Type>
      void Serialize( Type* p, TContainerRise& c );
      template <typename Type>
      void Deserialize( Type*& p, char* serData, int size );
      template <typename Type>
      void Fill( Type* p, char* serData, int size );
    
      // pack / unpack
      template <typename Type>
      void Pack( Type* p, TContainerRise& c );
      // WARNING! handle in {} определяется настройками генератора
      void Unpack( char* packedData, int size );
    
      TypeID GetID( char* packedData, int size );
      template <typename Type>
      Type* HandleUnpack( char* packedData, int size );
      template <typename Type>
      void FillUnpack( Type* p, char* packedData, int size );
    
      template <typename Type>
      static void Deallocate( Type* p );
    private:
      void PushIsNotNullptr( void* p );
      bool PopIsNotNullptr();
    
      template <typename Type>
      static Type* Allocate();
      template <typename Type>
      void _Deserialize( Type*& p, char* serData, int size, bool checkPtr );
      TypeID PrepareForUnpackPopMaster( char* packedData, int size );
    private:
        void _Serialize( TFloat3* p );
        void _Deserialize( TFloat3* p );
        TypeID _GetTypeID( TFloat3* p );
        static void _Deallocate( TFloat3* p );
        
        void _Serialize( TFloat4* p );
        void _Deserialize( TFloat4* p );
        TypeID _GetTypeID( TFloat4* p );
        static void _Deallocate( TFloat4* p );
        
        void _Serialize( TParamClass* p );
        void _Deserialize( TParamClass* p );
        TypeID _GetTypeID( TParamClass* p );
        static void _Deallocate( TParamClass* p );
        
        void _Serialize( TTestClass* p );
        void _Deserialize( TTestClass* p );
        TypeID _GetTypeID( TTestClass* p );
        static void _Deallocate( TTestClass* p );
        
        void _Serialize( nsBS::TBaseStruct* p );
        void _Deserialize( nsBS::TBaseStruct* p );
        TypeID _GetTypeID( nsBS::TBaseStruct* p );
        static void _Deallocate( nsBS::TBaseStruct* p );
        
        void _Serialize( nsBS::TTestStruct* p );
        void _Deserialize( nsBS::TTestStruct* p );
        TypeID _GetTypeID( nsBS::TTestStruct* p );
        static void _Deallocate( nsBS::TTestStruct* p );
        
        void _Serialize( nsMathTools::TMatrix16* p );
        void _Deserialize( nsMathTools::TMatrix16* p );
        TypeID _GetTypeID( nsMathTools::TMatrix16* p );
        static void _Deallocate( nsMathTools::TMatrix16* p );
        
        void _Serialize( nsMathTools::TMatrix9* p );
        void _Deserialize( nsMathTools::TMatrix9* p );
        TypeID _GetTypeID( nsMathTools::TMatrix9* p );
        static void _Deallocate( nsMathTools::TMatrix9* p );
        
        void _Serialize( nsMathTools::TOrientation* p );
        void _Deserialize( nsMathTools::TOrientation* p );
        TypeID _GetTypeID( nsMathTools::TOrientation* p );
        static void _Deallocate( nsMathTools::TOrientation* p );
        
        void _Serialize( nsMathTools::TPlane* p );
        void _Deserialize( nsMathTools::TPlane* p );
        TypeID _GetTypeID( nsMathTools::TPlane* p );
        static void _Deallocate( nsMathTools::TPlane* p );
        
        void _Serialize( nsMathTools::TPoint2* p );
        void _Deserialize( nsMathTools::TPoint2* p );
        TypeID _GetTypeID( nsMathTools::TPoint2* p );
        static void _Deallocate( nsMathTools::TPoint2* p );
        
        void _Serialize( nsMathTools::TQuaternion* p );
        void _Deserialize( nsMathTools::TQuaternion* p );
        TypeID _GetTypeID( nsMathTools::TQuaternion* p );
        static void _Deallocate( nsMathTools::TQuaternion* p );
        
        void _Serialize( nsMathTools::TVector2* p );
        void _Deserialize( nsMathTools::TVector2* p );
        TypeID _GetTypeID( nsMathTools::TVector2* p );
        static void _Deallocate( nsMathTools::TVector2* p );
        
        void _Serialize( nsMathTools::TVector3* p );
        void _Deserialize( nsMathTools::TVector3* p );
        TypeID _GetTypeID( nsMathTools::TVector3* p );
        static void _Deallocate( nsMathTools::TVector3* p );
        
        void _Serialize( nsMathTools::TVector4* p );
        void _Deserialize( nsMathTools::TVector4* p );
        TypeID _GetTypeID( nsMathTools::TVector4* p );
        static void _Deallocate( nsMathTools::TVector4* p );
        
        void _Serialize( nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig* p );
        void _Deserialize( nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig* p );
        static void _Deallocate( nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig* p );
        
        void _Serialize( nsReflectionCodeGenerator::TClassDesc* p );
        void _Deserialize( nsReflectionCodeGenerator::TClassDesc* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TClassDesc* p );
        static void _Deallocate( nsReflectionCodeGenerator::TClassDesc* p );
        
        void _Serialize( nsReflectionCodeGenerator::TConfig* p );
        void _Deserialize( nsReflectionCodeGenerator::TConfig* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TConfig* p );
        static void _Deallocate( nsReflectionCodeGenerator::TConfig* p );
        
        void _Serialize( nsReflectionCodeGenerator::TFilter* p );
        void _Deserialize( nsReflectionCodeGenerator::TFilter* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TFilter* p );
        static void _Deallocate( nsReflectionCodeGenerator::TFilter* p );
        
        void _Serialize( nsReflectionCodeGenerator::TImplementation* p );
        void _Deserialize( nsReflectionCodeGenerator::TImplementation* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TImplementation* p );
        static void _Deallocate( nsReflectionCodeGenerator::TImplementation* p );
        
        void _Serialize( nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig* p );
        void _Deserialize( nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig* p );
        static void _Deallocate( nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig* p );
        
        void _Serialize( nsReflectionCodeGenerator::TSqlGeneratorConfig* p );
        void _Deserialize( nsReflectionCodeGenerator::TSqlGeneratorConfig* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TSqlGeneratorConfig* p );
        static void _Deallocate( nsReflectionCodeGenerator::TSqlGeneratorConfig* p );
        
        void _Serialize( nsReflectionCodeGenerator::TTargetForCodeGeneration* p );
        void _Deserialize( nsReflectionCodeGenerator::TTargetForCodeGeneration* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TTargetForCodeGeneration* p );
        static void _Deallocate( nsReflectionCodeGenerator::TTargetForCodeGeneration* p );
        
        void _Serialize( nsReflectionCodeGenerator::TTargetForParsing* p );
        void _Deserialize( nsReflectionCodeGenerator::TTargetForParsing* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TTargetForParsing* p );
        static void _Deallocate( nsReflectionCodeGenerator::TTargetForParsing* p );
        
        void _Serialize( nsReflectionCodeGenerator::TUnpackHandler* p );
        void _Deserialize( nsReflectionCodeGenerator::TUnpackHandler* p );
        TypeID _GetTypeID( nsReflectionCodeGenerator::TUnpackHandler* p );
        static void _Deallocate( nsReflectionCodeGenerator::TUnpackHandler* p );
        
    };
    //-----------------------------------------------------------------------------
    template <typename Type>
    void TBinaryMarshaller::Serialize( Type* p, TContainerRise& c )
    {
      mPushMaster.Clear();
      _Serialize( p );
      mPushMaster.CopyInBuffer( c, 0 );
    }
    //-----------------------------------------------------------------------------
    template <typename Type>
    void TBinaryMarshaller::Deserialize( Type*& p, char* serData, int size )
    {
      _Deserialize( p, serData, size, true );
    }
    //-----------------------------------------------------------------------------
    template <typename Type>
    void TBinaryMarshaller::Fill( Type* p, char* serData, int size )
    {
      _Deserialize( p, serData, size, false );
    }
    //-----------------------------------------------------------------------------
    template <typename Type>
    void TBinaryMarshaller::Pack( Type* p, TContainerRise& c )
    {
      Serialize( p, c );
    
      int headerSize = sizeof( THeader );
      THeader header;
      header.type = _GetTypeID( p );
      header.useCompression = 0;
      header.ratio = 0;
      if ( c.GetSize() - headerSize > mSetLimitForCompression )
      {
        header.useCompression = 1;
        // compression
        mBuffer.Clear();
        mBuffer.Shift( LZ4_compressBound( c.GetSize() ) );
        int compressedSize = LZ4_compress_default( c.GetPtr(), mBuffer.GetPtr(),
          c.GetSize(), mBuffer.GetSize() );
        header.ratio = c.GetSize() / compressedSize + 1;
    
        c.Clear();
        c.Shift( headerSize + compressedSize );
        memcpy( c.GetPtr() + headerSize, mBuffer.GetPtr(), compressedSize );
      }
      else
      {
        auto size = c.GetSize();
        c.Shift( headerSize );
        memmove( c.GetPtr() + headerSize, c.GetPtr(), size );
      }
      memcpy( c.GetPtr(), &header, headerSize );
    }
    //-----------------------------------------------------------------------------
    template <typename Type>
    Type* TBinaryMarshaller::HandleUnpack( char* packedData, int size )
    {
      Type* p = nullptr;
      auto typeFromBinary = PrepareForUnpackPopMaster( packedData, size );
      auto typeByUserGuest = _GetTypeID( p );
      BL_ASSERT( typeFromBinary == typeByUserGuest );
      p = Allocate<Type>();
      _Deserialize( p );
      return p;
    }
    //-----------------------------------------------------------------------------
    template <typename Type>
    void TBinaryMarshaller::FillUnpack( Type* p, char* packedData, int size )
    {
      auto typeFromBinary = PrepareForUnpackPopMaster( packedData, size );
      auto typeByUserGuest = _GetTypeID( p );
      BL_ASSERT( typeFromBinary == typeByUserGuest );
      _Deserialize( p );
    }
    //-----------------------------------------------------------------------------
    template <typename Type>
    void TBinaryMarshaller::Deallocate( Type* p )
    {
      _Deallocate( p );
      TMemoryObjectPoolAllocator::DeallocateFunc( p );
    }
    //-----------------------------------------------------------------------------
    template <typename Type>
    static Type* TBinaryMarshaller::Allocate()
    {
      return TMemoryObjectPoolAllocator::AllocateFunc<Type>();
    }
    //-----------------------------------------------------------------------------
    template <typename Type>
    void TBinaryMarshaller::_Deserialize( Type*& p, char* serData, int size, bool checkPtr )
    {
      if ( checkPtr )
        p = p ? p : new Type();
    
      mPopMaster.SetBuffer( serData, size, 0 );
      _Deserialize( p );
    }
}
