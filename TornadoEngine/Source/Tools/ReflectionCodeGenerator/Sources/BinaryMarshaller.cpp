/*
Author: Gudakov Ramil Sergeevich a.k.a.Gauss
Гудаков Рамиль Сергеевич
Contacts : [ramil2085@mail.ru, ramil2085@gmail.com]
See for more information License.h.
*/
// File has been generated by ReflectionCodeGenerator version 0.99 build 20, at 2019_01_27 12:26:34.506
	
#include "BinaryMarshaller.h"
#include "UnpackHandler.h"

using namespace nsBinary;

void TBinaryMarshaller::SetLimitForCompression( int binarySize )
{
  mSetLimitForCompression = binarySize;
}
//-----------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::GetID( char* packedData, int size )
{
  auto pHeader = (THeader*) packedData;
  return pHeader->type;
}
//-----------------------------------------------------------------------------
void TBinaryMarshaller::PushIsNotNullptr( void* p )
{
  unsigned char isNullptr = p == nullptr ? 0 : 1;
  mPushMaster.PushNum( isNullptr );
}
//-----------------------------------------------------------------------------
bool TBinaryMarshaller::PopIsNotNullptr()
{
  unsigned char isNullptr;
  mPopMaster.PopNum( isNullptr );
  return ( isNullptr != 0 );
}
//-----------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::PrepareForUnpackPopMaster( char* packedData, int size )
{
  int headerSize = sizeof( THeader );
  THeader header;
  memcpy( &header, packedData, headerSize );
  char* pObj = packedData + headerSize;
  int objSize = size - headerSize;

  // decompression
  if ( header.useCompression )
  {
    mBuffer.Clear();
    mBuffer.Shift( objSize * header.ratio );// расширить для запаса под декомпрессию
    int decompressedRes = LZ4_decompress_safe( pObj, mBuffer.GetPtr(), objSize, mBuffer.GetSize() );
    mBuffer.Clear();
    mBuffer.Shift( decompressedRes );
  }
  else
  {
    mBuffer.Clear();
    mBuffer.Append( objSize, pObj );
  }
  mPopMaster.SetBuffer( &mBuffer, 0 );
  return header.type;
}
//-----------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::Unpack( char* packedData, int size )
{
  auto type = PrepareForUnpackPopMaster( packedData, size );
  switch( type )
  {
    case e_TFloat3:
    {
      auto p = Allocate<TFloat3>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TFloat4:
    {
      auto p = Allocate<TFloat4>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TParamClass:
    {
      auto p = Allocate<TParamClass>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_TTestClass:
    {
      auto p = Allocate<TTestClass>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsBS_TBaseStruct:
    {
      auto p = Allocate<nsBS::TBaseStruct>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsBS_TTestStruct:
    {
      auto p = Allocate<nsBS::TTestStruct>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsReflectionCodeGenerator_TBinaryMarshallerGeneratorConfig:
    {
      auto p = Allocate<nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsReflectionCodeGenerator_TClassDesc:
    {
      auto p = Allocate<nsReflectionCodeGenerator::TClassDesc>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsReflectionCodeGenerator_TConfig:
    {
      auto p = Allocate<nsReflectionCodeGenerator::TConfig>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsReflectionCodeGenerator_TFilter:
    {
      auto p = Allocate<nsReflectionCodeGenerator::TFilter>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsReflectionCodeGenerator_TImplementation:
    {
      auto p = Allocate<nsReflectionCodeGenerator::TImplementation>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsReflectionCodeGenerator_TJsonSerializerGeneratorConfig:
    {
      auto p = Allocate<nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsReflectionCodeGenerator_TTargetForCodeGeneration:
    {
      auto p = Allocate<nsReflectionCodeGenerator::TTargetForCodeGeneration>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsReflectionCodeGenerator_TTargetForParsing:
    {
      auto p = Allocate<nsReflectionCodeGenerator::TTargetForParsing>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
    case e_nsReflectionCodeGenerator_TUnpackHandler:
    {
      auto p = Allocate<nsReflectionCodeGenerator::TUnpackHandler>();
      _Deserialize( p );
      TUnpackHandler::Handle( p );
    }
    break;
  }
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TFloat3* p )
{
  mPushMaster.PushNum( p->x );
  mPushMaster.PushNum( p->y );
  mPushMaster.PushNum( p->z );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TFloat3* p )
{
  mPopMaster.PopNum( p->x );
  mPopMaster.PopNum( p->y );
  mPopMaster.PopNum( p->z );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TFloat3* p )
{
  return e_TFloat3;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TFloat4* p )
{
  mPushMaster.PushNum( p->x );
  mPushMaster.PushNum( p->y );
  mPushMaster.PushNum( p->z );
  mPushMaster.PushNum( p->w );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TFloat4* p )
{
  mPopMaster.PopNum( p->x );
  mPopMaster.PopNum( p->y );
  mPopMaster.PopNum( p->z );
  mPopMaster.PopNum( p->w );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TFloat4* p )
{
  return e_TFloat4;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TParamClass* p )
{
  mPushMaster.PushNum( p->id );
  auto pos_p = &(p->pos);
  PushIsNotNullptr( pos_p );
  if ( pos_p )
    _Serialize( pos_p );
  auto rot_p = &(p->rot);
  PushIsNotNullptr( rot_p );
  if ( rot_p )
    _Serialize( rot_p );
  auto vel_p = &(p->vel);
  PushIsNotNullptr( vel_p );
  if ( vel_p )
    _Serialize( vel_p );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TParamClass* p )
{
  mPopMaster.PopNum( p->id );
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->pos) );
  }
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->rot) );
  }
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->vel) );
  }
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TParamClass* p )
{
  return e_TParamClass;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( TTestClass* p )
{
  mPushMaster.PushSerObjArray<TParamClass>( p->vParam, [this]( TParamClass* p ) { _Serialize( p ); } );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( TTestClass* p )
{
  mPopMaster.PopSerObjArray<TParamClass>( p->vParam, [this]( TParamClass* p ) { _Deserialize( p ); } );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( TTestClass* p )
{
  return e_TTestClass;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsBS::TBaseStruct* p )
{
  mPushMaster.PushStr( p->s );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsBS::TBaseStruct* p )
{
  mPopMaster.PopStr( p->s );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsBS::TBaseStruct* p )
{
  return e_nsBS_TBaseStruct;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsBS::TTestStruct* p )
{
  _Serialize( (nsBS::TBaseStruct*)p );
  auto baseStruct_p = &(p->baseStruct);
  PushIsNotNullptr( baseStruct_p );
  if ( baseStruct_p )
    _Serialize( baseStruct_p );
  auto pBaseStruct_p = p->pBaseStruct;
  PushIsNotNullptr( pBaseStruct_p );
  if ( pBaseStruct_p )
    _Serialize( pBaseStruct_p );
  auto spBaseStruct_p = p->spBaseStruct.get();
  PushIsNotNullptr( spBaseStruct_p );
  if ( spBaseStruct_p )
    _Serialize( spBaseStruct_p );
  mPushMaster.PushStr( p->password );
  mPushMaster.PushNum( p->port );
  mPushMaster.PushBool( p->flag );
  mPushMaster.PushStrArray( p->strSet );
  mPushMaster.PushNumArray<int>( p->intSet );
  mPushMaster.PushBoolArray( p->boolList );
  mPushMaster.PushNumArray<int>( p->numList );
  mPushMaster.PushNumArray<int>( p->numVector );
  mPushMaster.PushStrArray( p->strVector );
  mPushMaster.PushSerObjArray<nsBS::TBaseStruct>( p->baseVec, [this]( nsBS::TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushSerPtrArray<nsBS::TBaseStruct>( p->basePtrVec, [this]( nsBS::TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushSerSmartPtrArray<nsBS::TBaseStruct, std::shared_ptr<nsBS::TBaseStruct>>( p->baseSPVec, [this]( nsBS::TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumNumMap<int, int>( p->intIntMap );
  mPushMaster.PushNumBoolMap<int>( p->intBoolMap );
  mPushMaster.PushNumStrMap<int>( p->intStrMap );
  mPushMaster.PushStrStrMap( p->strStrMap );
  mPushMaster.PushStrNumMap<int>( p->strIntMap );
  mPushMaster.PushStrBoolMap( p->strBoolMap );
  mPushMaster.PushStrSerObjMap<nsBS::TBaseStruct>( p->strBaseMap, [this]( nsBS::TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushStrSerPtrMap<nsBS::TBaseStruct>( p->strBasePtrMap, [this]( nsBS::TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushStrSerSmartPtrMap<nsBS::TBaseStruct, std::shared_ptr<nsBS::TBaseStruct>>( p->strBaseSPMap, [this]( nsBS::TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumSerObjMap<int, nsBS::TBaseStruct>( p->intBaseMap, [this]( nsBS::TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumSerPtrMap<int, nsBS::TBaseStruct>( p->intBasePtrMap, [this]( nsBS::TBaseStruct* p ) { _Serialize( p ); } );
  mPushMaster.PushNumSerSmartPtrMap<int, nsBS::TBaseStruct, std::shared_ptr<nsBS::TBaseStruct>>( p->intBaseSPMap, [this]( nsBS::TBaseStruct* p ) { _Serialize( p ); } );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsBS::TTestStruct* p )
{
  _Deserialize( (nsBS::TBaseStruct*)p );
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->baseStruct) );
  }
  if ( PopIsNotNullptr() )
  {
    if ( p->pBaseStruct == nullptr  )
      p->pBaseStruct = new nsBS::TBaseStruct();
    _Deserialize( p->pBaseStruct );
  }
  if ( PopIsNotNullptr() )
  {
    if ( p->spBaseStruct.get() == nullptr  )
      p->spBaseStruct.reset( new nsBS::TBaseStruct() );
    _Deserialize( p->spBaseStruct.get() );
  }
  mPopMaster.PopStr( p->password );
  mPopMaster.PopNum( p->port );
  mPopMaster.PopBool( p->flag );
  mPopMaster.PopStrSet( p->strSet );
  mPopMaster.PopNumSet( p->intSet );
  mPopMaster.PopBoolArray( p->boolList );
  mPopMaster.PopNumArray<int>( p->numList );
  mPopMaster.PopNumArray<int>( p->numVector );
  mPopMaster.PopStrArray( p->strVector );
  mPopMaster.PopSerObjArray<nsBS::TBaseStruct>( p->baseVec, [this]( nsBS::TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopSerPtrArray<nsBS::TBaseStruct>( p->basePtrVec, [this]( nsBS::TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopSerSmartPtrArray<nsBS::TBaseStruct, std::shared_ptr<nsBS::TBaseStruct>>( p->baseSPVec, [this]( nsBS::TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumNumMap<int, int>( p->intIntMap );
  mPopMaster.PopNumBoolMap<int>( p->intBoolMap );
  mPopMaster.PopNumStrMap<int>( p->intStrMap );
  mPopMaster.PopStrStrMap( p->strStrMap );
  mPopMaster.PopStrNumMap<int>( p->strIntMap );
  mPopMaster.PopStrBoolMap( p->strBoolMap );
  mPopMaster.PopStrSerObjMap<nsBS::TBaseStruct>( p->strBaseMap, [this]( nsBS::TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopStrSerPtrMap<nsBS::TBaseStruct>( p->strBasePtrMap, [this]( nsBS::TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopStrSerSmartPtrMap<nsBS::TBaseStruct, std::shared_ptr<nsBS::TBaseStruct>>( p->strBaseSPMap, [this]( nsBS::TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumSerObjMap<int, nsBS::TBaseStruct>( p->intBaseMap, [this]( nsBS::TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumSerPtrMap<int, nsBS::TBaseStruct>( p->intBasePtrMap, [this]( nsBS::TBaseStruct* p ) { _Deserialize( p ); } );
  mPopMaster.PopNumSerSmartPtrMap<int, nsBS::TBaseStruct, std::shared_ptr<nsBS::TBaseStruct>>( p->intBaseSPMap, [this]( nsBS::TBaseStruct* p ) { _Deserialize( p ); } );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsBS::TTestStruct* p )
{
  return e_nsBS_TTestStruct;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig* p )
{
  _Serialize( (nsReflectionCodeGenerator::TClassDesc*)p );
  auto unpackHandler_p = &(p->unpackHandler);
  PushIsNotNullptr( unpackHandler_p );
  if ( unpackHandler_p )
    _Serialize( unpackHandler_p );
  mPushMaster.PushNum( p->beginID );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig* p )
{
  _Deserialize( (nsReflectionCodeGenerator::TClassDesc*)p );
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->unpackHandler) );
  }
  mPopMaster.PopNum( p->beginID );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig* p )
{
  return e_nsReflectionCodeGenerator_TBinaryMarshallerGeneratorConfig;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsReflectionCodeGenerator::TClassDesc* p )
{
  mPushMaster.PushStr( p->exportDeclaration );
  mPushMaster.PushStr( p->nameSpaceName );
  mPushMaster.PushStr( p->className );
  mPushMaster.PushStr( p->fileName );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsReflectionCodeGenerator::TClassDesc* p )
{
  mPopMaster.PopStr( p->exportDeclaration );
  mPopMaster.PopStr( p->nameSpaceName );
  mPopMaster.PopStr( p->className );
  mPopMaster.PopStr( p->fileName );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsReflectionCodeGenerator::TClassDesc* p )
{
  return e_nsReflectionCodeGenerator_TClassDesc;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsReflectionCodeGenerator::TConfig* p )
{
  auto targetForParsing_p = &(p->targetForParsing);
  PushIsNotNullptr( targetForParsing_p );
  if ( targetForParsing_p )
    _Serialize( targetForParsing_p );
  auto filter_p = &(p->filter);
  PushIsNotNullptr( filter_p );
  if ( filter_p )
    _Serialize( filter_p );
  auto targetForCodeGeneration_p = &(p->targetForCodeGeneration);
  PushIsNotNullptr( targetForCodeGeneration_p );
  if ( targetForCodeGeneration_p )
    _Serialize( targetForCodeGeneration_p );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsReflectionCodeGenerator::TConfig* p )
{
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->targetForParsing) );
  }
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->filter) );
  }
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->targetForCodeGeneration) );
  }
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsReflectionCodeGenerator::TConfig* p )
{
  return e_nsReflectionCodeGenerator_TConfig;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsReflectionCodeGenerator::TFilter* p )
{
  mPushMaster.PushStr( p->attribute );
  mPushMaster.PushStrArray( p->extensions );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsReflectionCodeGenerator::TFilter* p )
{
  mPopMaster.PopStr( p->attribute );
  mPopMaster.PopStrArray( p->extensions );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsReflectionCodeGenerator::TFilter* p )
{
  return e_nsReflectionCodeGenerator_TFilter;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsReflectionCodeGenerator::TImplementation* p )
{
  auto jsonSerializer_p = p->jsonSerializer.get();
  PushIsNotNullptr( jsonSerializer_p );
  if ( jsonSerializer_p )
    _Serialize( jsonSerializer_p );
  auto binaryMarshaller_p = p->binaryMarshaller.get();
  PushIsNotNullptr( binaryMarshaller_p );
  if ( binaryMarshaller_p )
    _Serialize( binaryMarshaller_p );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsReflectionCodeGenerator::TImplementation* p )
{
  if ( PopIsNotNullptr() )
  {
    if ( p->jsonSerializer.get() == nullptr  )
      p->jsonSerializer.reset( new nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig() );
    _Deserialize( p->jsonSerializer.get() );
  }
  if ( PopIsNotNullptr() )
  {
    if ( p->binaryMarshaller.get() == nullptr  )
      p->binaryMarshaller.reset( new nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig() );
    _Deserialize( p->binaryMarshaller.get() );
  }
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsReflectionCodeGenerator::TImplementation* p )
{
  return e_nsReflectionCodeGenerator_TImplementation;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig* p )
{
  _Serialize( (nsReflectionCodeGenerator::TClassDesc*)p );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig* p )
{
  _Deserialize( (nsReflectionCodeGenerator::TClassDesc*)p );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig* p )
{
  return e_nsReflectionCodeGenerator_TJsonSerializerGeneratorConfig;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsReflectionCodeGenerator::TTargetForCodeGeneration* p )
{
  mPushMaster.PushStr( p->directory );
  mPushMaster.PushStr( p->includeListFileName );
  auto implementation_p = &(p->implementation);
  PushIsNotNullptr( implementation_p );
  if ( implementation_p )
    _Serialize( implementation_p );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsReflectionCodeGenerator::TTargetForCodeGeneration* p )
{
  mPopMaster.PopStr( p->directory );
  mPopMaster.PopStr( p->includeListFileName );
  if ( PopIsNotNullptr() )
  {
    _Deserialize( &(p->implementation) );
  }
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsReflectionCodeGenerator::TTargetForCodeGeneration* p )
{
  return e_nsReflectionCodeGenerator_TTargetForCodeGeneration;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsReflectionCodeGenerator::TTargetForParsing* p )
{
  mPushMaster.PushStrArray( p->directories );
  mPushMaster.PushBool( p->recursive );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsReflectionCodeGenerator::TTargetForParsing* p )
{
  mPopMaster.PopStrArray( p->directories );
  mPopMaster.PopBool( p->recursive );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsReflectionCodeGenerator::TTargetForParsing* p )
{
  return e_nsReflectionCodeGenerator_TTargetForParsing;
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Serialize( nsReflectionCodeGenerator::TUnpackHandler* p )
{
  _Serialize( (nsReflectionCodeGenerator::TClassDesc*)p );
  mPushMaster.PushStr( p->method );
}
//---------------------------------------------------------------------------------------
void TBinaryMarshaller::_Deserialize( nsReflectionCodeGenerator::TUnpackHandler* p )
{
  _Deserialize( (nsReflectionCodeGenerator::TClassDesc*)p );
  mPopMaster.PopStr( p->method );
}
//---------------------------------------------------------------------------------------
TBinaryMarshaller::TypeID TBinaryMarshaller::_GetTypeID( nsReflectionCodeGenerator::TUnpackHandler* p )
{
  return e_nsReflectionCodeGenerator_TUnpackHandler;
}
//---------------------------------------------------------------------------------------
