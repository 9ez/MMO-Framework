/*
	ReflectionCodeGenerator
*/
// File has been generated by ReflectionCodeGenerator version 1.14 build 42, at 2020_09_13 14:04:07.752
	
#include "JsonSerializer.h"
#include "JsonPopMaster.h"
#include "JsonPushMaster.h"

using namespace nsJson;

using POM = TJsonPopMaster;
using PUM = TJsonPushMaster;

std::map<std::string, TJsonSerializer::TypeFunc> TJsonSerializer::mTypeNameFuncsMap;
std::list<std::string> TJsonSerializer::mTypeNameList;

void TJsonSerializer::Init()
{
    static bool isNeedInit = true;
    if ( !isNeedInit ) {
        return;
    }
    isNeedInit = false;
    
    TypeFunc _TFloat3TypeFunc;
    _TFloat3TypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<TFloat3>((TFloat3*) p, str);
    };
    _TFloat3TypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<TFloat3>((TFloat3*&) p, str);
    };
    _TFloat3TypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<TFloat3>((TFloat3*) p, str);
    };
    mTypeNameFuncsMap.insert({ "TFloat3", _TFloat3TypeFunc });
    mTypeNameList.push_back("TFloat3");
    
    TypeFunc _TFloat4TypeFunc;
    _TFloat4TypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<TFloat4>((TFloat4*) p, str);
    };
    _TFloat4TypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<TFloat4>((TFloat4*&) p, str);
    };
    _TFloat4TypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<TFloat4>((TFloat4*) p, str);
    };
    mTypeNameFuncsMap.insert({ "TFloat4", _TFloat4TypeFunc });
    mTypeNameList.push_back("TFloat4");
    
    TypeFunc _TParamClassTypeFunc;
    _TParamClassTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<TParamClass>((TParamClass*) p, str);
    };
    _TParamClassTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<TParamClass>((TParamClass*&) p, str);
    };
    _TParamClassTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<TParamClass>((TParamClass*) p, str);
    };
    mTypeNameFuncsMap.insert({ "TParamClass", _TParamClassTypeFunc });
    mTypeNameList.push_back("TParamClass");
    
    TypeFunc _TTestClassTypeFunc;
    _TTestClassTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<TTestClass>((TTestClass*) p, str);
    };
    _TTestClassTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<TTestClass>((TTestClass*&) p, str);
    };
    _TTestClassTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<TTestClass>((TTestClass*) p, str);
    };
    mTypeNameFuncsMap.insert({ "TTestClass", _TTestClassTypeFunc });
    mTypeNameList.push_back("TTestClass");
    
    TypeFunc _nsBS_TBaseStructTypeFunc;
    _nsBS_TBaseStructTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsBS::TBaseStruct>((nsBS::TBaseStruct*) p, str);
    };
    _nsBS_TBaseStructTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsBS::TBaseStruct>((nsBS::TBaseStruct*&) p, str);
    };
    _nsBS_TBaseStructTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsBS::TBaseStruct>((nsBS::TBaseStruct*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsBS::TBaseStruct", _nsBS_TBaseStructTypeFunc });
    mTypeNameList.push_back("nsBS::TBaseStruct");
    
    TypeFunc _nsBS_TTestStructTypeFunc;
    _nsBS_TTestStructTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsBS::TTestStruct>((nsBS::TTestStruct*) p, str);
    };
    _nsBS_TTestStructTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsBS::TTestStruct>((nsBS::TTestStruct*&) p, str);
    };
    _nsBS_TTestStructTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsBS::TTestStruct>((nsBS::TTestStruct*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsBS::TTestStruct", _nsBS_TTestStructTypeFunc });
    mTypeNameList.push_back("nsBS::TTestStruct");
    
    TypeFunc _nsMathTools_TMatrix16TypeFunc;
    _nsMathTools_TMatrix16TypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsMathTools::TMatrix16>((nsMathTools::TMatrix16*) p, str);
    };
    _nsMathTools_TMatrix16TypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsMathTools::TMatrix16>((nsMathTools::TMatrix16*&) p, str);
    };
    _nsMathTools_TMatrix16TypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsMathTools::TMatrix16>((nsMathTools::TMatrix16*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsMathTools::TMatrix16", _nsMathTools_TMatrix16TypeFunc });
    mTypeNameList.push_back("nsMathTools::TMatrix16");
    
    TypeFunc _nsMathTools_TMatrix9TypeFunc;
    _nsMathTools_TMatrix9TypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsMathTools::TMatrix9>((nsMathTools::TMatrix9*) p, str);
    };
    _nsMathTools_TMatrix9TypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsMathTools::TMatrix9>((nsMathTools::TMatrix9*&) p, str);
    };
    _nsMathTools_TMatrix9TypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsMathTools::TMatrix9>((nsMathTools::TMatrix9*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsMathTools::TMatrix9", _nsMathTools_TMatrix9TypeFunc });
    mTypeNameList.push_back("nsMathTools::TMatrix9");
    
    TypeFunc _nsMathTools_TOrientationTypeFunc;
    _nsMathTools_TOrientationTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsMathTools::TOrientation>((nsMathTools::TOrientation*) p, str);
    };
    _nsMathTools_TOrientationTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsMathTools::TOrientation>((nsMathTools::TOrientation*&) p, str);
    };
    _nsMathTools_TOrientationTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsMathTools::TOrientation>((nsMathTools::TOrientation*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsMathTools::TOrientation", _nsMathTools_TOrientationTypeFunc });
    mTypeNameList.push_back("nsMathTools::TOrientation");
    
    TypeFunc _nsMathTools_TPlaneTypeFunc;
    _nsMathTools_TPlaneTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsMathTools::TPlane>((nsMathTools::TPlane*) p, str);
    };
    _nsMathTools_TPlaneTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsMathTools::TPlane>((nsMathTools::TPlane*&) p, str);
    };
    _nsMathTools_TPlaneTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsMathTools::TPlane>((nsMathTools::TPlane*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsMathTools::TPlane", _nsMathTools_TPlaneTypeFunc });
    mTypeNameList.push_back("nsMathTools::TPlane");
    
    TypeFunc _nsMathTools_TPoint2TypeFunc;
    _nsMathTools_TPoint2TypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsMathTools::TPoint2>((nsMathTools::TPoint2*) p, str);
    };
    _nsMathTools_TPoint2TypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsMathTools::TPoint2>((nsMathTools::TPoint2*&) p, str);
    };
    _nsMathTools_TPoint2TypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsMathTools::TPoint2>((nsMathTools::TPoint2*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsMathTools::TPoint2", _nsMathTools_TPoint2TypeFunc });
    mTypeNameList.push_back("nsMathTools::TPoint2");
    
    TypeFunc _nsMathTools_TQuaternionTypeFunc;
    _nsMathTools_TQuaternionTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsMathTools::TQuaternion>((nsMathTools::TQuaternion*) p, str);
    };
    _nsMathTools_TQuaternionTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsMathTools::TQuaternion>((nsMathTools::TQuaternion*&) p, str);
    };
    _nsMathTools_TQuaternionTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsMathTools::TQuaternion>((nsMathTools::TQuaternion*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsMathTools::TQuaternion", _nsMathTools_TQuaternionTypeFunc });
    mTypeNameList.push_back("nsMathTools::TQuaternion");
    
    TypeFunc _nsMathTools_TVector2TypeFunc;
    _nsMathTools_TVector2TypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsMathTools::TVector2>((nsMathTools::TVector2*) p, str);
    };
    _nsMathTools_TVector2TypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsMathTools::TVector2>((nsMathTools::TVector2*&) p, str);
    };
    _nsMathTools_TVector2TypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsMathTools::TVector2>((nsMathTools::TVector2*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsMathTools::TVector2", _nsMathTools_TVector2TypeFunc });
    mTypeNameList.push_back("nsMathTools::TVector2");
    
    TypeFunc _nsMathTools_TVector3TypeFunc;
    _nsMathTools_TVector3TypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsMathTools::TVector3>((nsMathTools::TVector3*) p, str);
    };
    _nsMathTools_TVector3TypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsMathTools::TVector3>((nsMathTools::TVector3*&) p, str);
    };
    _nsMathTools_TVector3TypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsMathTools::TVector3>((nsMathTools::TVector3*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsMathTools::TVector3", _nsMathTools_TVector3TypeFunc });
    mTypeNameList.push_back("nsMathTools::TVector3");
    
    TypeFunc _nsMathTools_TVector4TypeFunc;
    _nsMathTools_TVector4TypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsMathTools::TVector4>((nsMathTools::TVector4*) p, str);
    };
    _nsMathTools_TVector4TypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsMathTools::TVector4>((nsMathTools::TVector4*&) p, str);
    };
    _nsMathTools_TVector4TypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsMathTools::TVector4>((nsMathTools::TVector4*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsMathTools::TVector4", _nsMathTools_TVector4TypeFunc });
    mTypeNameList.push_back("nsMathTools::TVector4");
    
    TypeFunc _nsReflectionCodeGenerator_TBinaryMarshallerGeneratorConfigTypeFunc;
    _nsReflectionCodeGenerator_TBinaryMarshallerGeneratorConfigTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig>((nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig*) p, str);
    };
    _nsReflectionCodeGenerator_TBinaryMarshallerGeneratorConfigTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig>((nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig*&) p, str);
    };
    _nsReflectionCodeGenerator_TBinaryMarshallerGeneratorConfigTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig>((nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig", _nsReflectionCodeGenerator_TBinaryMarshallerGeneratorConfigTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig");
    
    TypeFunc _nsReflectionCodeGenerator_TClassDescTypeFunc;
    _nsReflectionCodeGenerator_TClassDescTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TClassDesc>((nsReflectionCodeGenerator::TClassDesc*) p, str);
    };
    _nsReflectionCodeGenerator_TClassDescTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TClassDesc>((nsReflectionCodeGenerator::TClassDesc*&) p, str);
    };
    _nsReflectionCodeGenerator_TClassDescTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TClassDesc>((nsReflectionCodeGenerator::TClassDesc*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TClassDesc", _nsReflectionCodeGenerator_TClassDescTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TClassDesc");
    
    TypeFunc _nsReflectionCodeGenerator_TConfigTypeFunc;
    _nsReflectionCodeGenerator_TConfigTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TConfig>((nsReflectionCodeGenerator::TConfig*) p, str);
    };
    _nsReflectionCodeGenerator_TConfigTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TConfig>((nsReflectionCodeGenerator::TConfig*&) p, str);
    };
    _nsReflectionCodeGenerator_TConfigTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TConfig>((nsReflectionCodeGenerator::TConfig*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TConfig", _nsReflectionCodeGenerator_TConfigTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TConfig");
    
    TypeFunc _nsReflectionCodeGenerator_TFilterTypeFunc;
    _nsReflectionCodeGenerator_TFilterTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TFilter>((nsReflectionCodeGenerator::TFilter*) p, str);
    };
    _nsReflectionCodeGenerator_TFilterTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TFilter>((nsReflectionCodeGenerator::TFilter*&) p, str);
    };
    _nsReflectionCodeGenerator_TFilterTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TFilter>((nsReflectionCodeGenerator::TFilter*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TFilter", _nsReflectionCodeGenerator_TFilterTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TFilter");
    
    TypeFunc _nsReflectionCodeGenerator_TImplementationTypeFunc;
    _nsReflectionCodeGenerator_TImplementationTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TImplementation>((nsReflectionCodeGenerator::TImplementation*) p, str);
    };
    _nsReflectionCodeGenerator_TImplementationTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TImplementation>((nsReflectionCodeGenerator::TImplementation*&) p, str);
    };
    _nsReflectionCodeGenerator_TImplementationTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TImplementation>((nsReflectionCodeGenerator::TImplementation*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TImplementation", _nsReflectionCodeGenerator_TImplementationTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TImplementation");
    
    TypeFunc _nsReflectionCodeGenerator_TJsonSerializerGeneratorConfigTypeFunc;
    _nsReflectionCodeGenerator_TJsonSerializerGeneratorConfigTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig>((nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig*) p, str);
    };
    _nsReflectionCodeGenerator_TJsonSerializerGeneratorConfigTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig>((nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig*&) p, str);
    };
    _nsReflectionCodeGenerator_TJsonSerializerGeneratorConfigTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig>((nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig", _nsReflectionCodeGenerator_TJsonSerializerGeneratorConfigTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig");
    
    TypeFunc _nsReflectionCodeGenerator_TSqlGeneratorConfigTypeFunc;
    _nsReflectionCodeGenerator_TSqlGeneratorConfigTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TSqlGeneratorConfig>((nsReflectionCodeGenerator::TSqlGeneratorConfig*) p, str);
    };
    _nsReflectionCodeGenerator_TSqlGeneratorConfigTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TSqlGeneratorConfig>((nsReflectionCodeGenerator::TSqlGeneratorConfig*&) p, str);
    };
    _nsReflectionCodeGenerator_TSqlGeneratorConfigTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TSqlGeneratorConfig>((nsReflectionCodeGenerator::TSqlGeneratorConfig*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TSqlGeneratorConfig", _nsReflectionCodeGenerator_TSqlGeneratorConfigTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TSqlGeneratorConfig");
    
    TypeFunc _nsReflectionCodeGenerator_TTargetForCodeGenerationTypeFunc;
    _nsReflectionCodeGenerator_TTargetForCodeGenerationTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TTargetForCodeGeneration>((nsReflectionCodeGenerator::TTargetForCodeGeneration*) p, str);
    };
    _nsReflectionCodeGenerator_TTargetForCodeGenerationTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TTargetForCodeGeneration>((nsReflectionCodeGenerator::TTargetForCodeGeneration*&) p, str);
    };
    _nsReflectionCodeGenerator_TTargetForCodeGenerationTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TTargetForCodeGeneration>((nsReflectionCodeGenerator::TTargetForCodeGeneration*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TTargetForCodeGeneration", _nsReflectionCodeGenerator_TTargetForCodeGenerationTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TTargetForCodeGeneration");
    
    TypeFunc _nsReflectionCodeGenerator_TTargetForParsingTypeFunc;
    _nsReflectionCodeGenerator_TTargetForParsingTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TTargetForParsing>((nsReflectionCodeGenerator::TTargetForParsing*) p, str);
    };
    _nsReflectionCodeGenerator_TTargetForParsingTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TTargetForParsing>((nsReflectionCodeGenerator::TTargetForParsing*&) p, str);
    };
    _nsReflectionCodeGenerator_TTargetForParsingTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TTargetForParsing>((nsReflectionCodeGenerator::TTargetForParsing*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TTargetForParsing", _nsReflectionCodeGenerator_TTargetForParsingTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TTargetForParsing");
    
    TypeFunc _nsReflectionCodeGenerator_TUnpackHandlerTypeFunc;
    _nsReflectionCodeGenerator_TUnpackHandlerTypeFunc.serializeFunc = [] (void* p, std::string& str) {
    Serialize<nsReflectionCodeGenerator::TUnpackHandler>((nsReflectionCodeGenerator::TUnpackHandler*) p, str);
    };
    _nsReflectionCodeGenerator_TUnpackHandlerTypeFunc.deserializeFunc = [] (void*& p, const std::string& str) {
        Deserialize<nsReflectionCodeGenerator::TUnpackHandler>((nsReflectionCodeGenerator::TUnpackHandler*&) p, str);
    };
    _nsReflectionCodeGenerator_TUnpackHandlerTypeFunc.fillFunc = [] (void* p, const std::string& str) {
        Fill<nsReflectionCodeGenerator::TUnpackHandler>((nsReflectionCodeGenerator::TUnpackHandler*) p, str);
    };
    mTypeNameFuncsMap.insert({ "nsReflectionCodeGenerator::TUnpackHandler", _nsReflectionCodeGenerator_TUnpackHandlerTypeFunc });
    mTypeNameList.push_back("nsReflectionCodeGenerator::TUnpackHandler");
    
}
//---------------------------------------------------------------------------------------
const std::list<std::string>& TJsonSerializer::GetTypeNameList()
{
    Init();
    return mTypeNameList;
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::Serialize(void* p, std::string & str, const std::string & typeName)
{
    Init();
    mTypeNameFuncsMap[typeName].serializeFunc(p, str);
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::Deserialize(void*& p, const std::string & str, const std::string & typeName)
{
    Init();
    mTypeNameFuncsMap[typeName].deserializeFunc(p, str);
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::Fill(void* p, const std::string & str, const std::string & typeName)
{
    Init();
    mTypeNameFuncsMap[typeName].fillFunc(p, str);
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( TFloat3* p, Jobj& obj )
{
    PUM::Push( obj, "x", p->x );
    PUM::Push( obj, "y", p->y );
    PUM::Push( obj, "z", p->z );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( TFloat3* p, const json11::Json& json )
{
    POM::PopNum( json, "x", p->x );
    POM::PopNum( json, "y", p->y );
    POM::PopNum( json, "z", p->z );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( TFloat4* p, Jobj& obj )
{
    PUM::Push( obj, "x", p->x );
    PUM::Push( obj, "y", p->y );
    PUM::Push( obj, "z", p->z );
    PUM::Push( obj, "w", p->w );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( TFloat4* p, const json11::Json& json )
{
    POM::PopNum( json, "x", p->x );
    POM::PopNum( json, "y", p->y );
    POM::PopNum( json, "z", p->z );
    POM::PopNum( json, "w", p->w );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( TParamClass* p, Jobj& obj )
{
    PUM::Push( obj, "id", p->id );
    Jobj pos_obj;
    _Serialize( &(p->pos), pos_obj );
    PUM::Push( obj, "pos", pos_obj );
    Jobj rot_obj;
    _Serialize( &(p->rot), rot_obj );
    PUM::Push( obj, "rot", rot_obj );
    Jobj vel_obj;
    _Serialize( &(p->vel), vel_obj );
    PUM::Push( obj, "vel", vel_obj );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( TParamClass* p, const json11::Json& json )
{
    POM::PopNum( json, "id", p->id );
    auto& pos_json = json["pos"];
    _Deserialize( &(p->pos), pos_json );
    auto& rot_json = json["rot"];
    _Deserialize( &(p->rot), rot_json );
    auto& vel_json = json["vel"];
    _Deserialize( &(p->vel), vel_json );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( TTestClass* p, Jobj& obj )
{
    
    Jarr vParam_c0;
    for ( int vParam_i0 = 0 ; vParam_i0 < p->vParam.size() ; vParam_i0++ )
    {
        auto& vParam_e0 = p->vParam[vParam_i0];
        Jobj vParam_e0_obj;
        auto& vParam_e0_value = vParam_e0;
        auto vParam_e0_ptr = &vParam_e0_value;
        if ( vParam_e0_ptr )
        {
            _Serialize( vParam_e0_ptr, vParam_e0_obj );
            vParam_c0.push_back( vParam_e0_obj );
        }
        else
            vParam_c0.push_back( nullptr );
    }
    PUM::Push( obj, "vParam", vParam_c0 );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( TTestClass* p, const json11::Json& json )
{
    
    auto& vParam_src0 = json["vParam"].array_items();
    for ( auto& vParam_e0 : vParam_src0 )
    {
        auto& first_e0 = vParam_e0;
        TParamClass vParam_newObj0;
        if ( first_e0.is_null() == false )
        {
            _Deserialize( &vParam_newObj0, first_e0 );
        }
        p->vParam.push_back( vParam_newObj0 );
    }
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsBS::TBaseStruct* p, Jobj& obj )
{
    
    Jobj iiMap_c0;
    for ( auto& iiMap_e0 : p->iiMap )
    {
        iiMap_c0.insert( { PUM::ConvertToString( iiMap_e0.first ), iiMap_e0.second } );
    }
    PUM::PushMap( obj, "iiMap", iiMap_c0 );
    PUM::Push( obj, "a", p->a );
    PUM::Push( obj, "b", p->b );
    PUM::Push( obj, "c", p->c );
    PUM::Push( obj, "d", p->d );
    PUM::Push( obj, "s", p->s );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsBS::TBaseStruct* p, const json11::Json& json )
{
    
    auto& iiMap_src0 = json["iiMap"].object_items();
    for ( auto& iiMap_e0 : iiMap_src0 )
    {
        p->iiMap.insert( { (int)(std::stod( iiMap_e0.first )), (int)(iiMap_e0.second.number_value()) } );
    }
    POM::PopNum( json, "a", p->a );
    POM::PopNum( json, "b", p->b );
    POM::PopNum( json, "c", p->c );
    POM::PopNum( json, "d", p->d );
    POM::PopStr( json, "s", p->s );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsBS::TTestStruct* p, Jobj& obj )
{
    _Serialize( (nsBS::TBaseStruct*)p, obj);
    Jobj baseStruct_obj;
    _Serialize( &(p->baseStruct), baseStruct_obj );
    PUM::Push( obj, "baseStruct", baseStruct_obj );
    Jobj pBaseStruct_obj;
    auto p_pBaseStruct = p->pBaseStruct;
    if ( p_pBaseStruct )
    {
        _Serialize( p_pBaseStruct, pBaseStruct_obj );
        PUM::Push( obj, "pBaseStruct", pBaseStruct_obj );
    }
    else
        PUM::PushNull( obj, "pBaseStruct" );
    Jobj spBaseStruct_obj;
    auto p_spBaseStruct = p->spBaseStruct.get();
    if ( p_spBaseStruct )
    {
        _Serialize( p_spBaseStruct, spBaseStruct_obj );
        PUM::Push( obj, "spBaseStruct", spBaseStruct_obj );
    }
    else
        PUM::PushNull( obj, "spBaseStruct" );
    PUM::Push( obj, "password", p->password );
    PUM::Push( obj, "port", p->port );
    PUM::Push( obj, "flag", p->flag );
    PUM::Push( obj, "strSet", p->strSet );
    PUM::Push( obj, "intSet", p->intSet );
    
    Jarr boolList_c0;
    for ( auto& boolList_e0 : p->boolList )
    {
        boolList_c0.push_back( boolList_e0 );
    }
    PUM::Push( obj, "boolList", boolList_c0 );
    
    Jarr numList_c0;
    for ( auto& numList_e0 : p->numList )
    {
        numList_c0.push_back( numList_e0 );
    }
    PUM::Push( obj, "numList", numList_c0 );
    
    Jarr numVector_c0;
    for ( int numVector_i0 = 0 ; numVector_i0 < p->numVector.size() ; numVector_i0++ )
    {
        auto& numVector_e0 = p->numVector[numVector_i0];
        numVector_c0.push_back( numVector_e0 );
    }
    PUM::Push( obj, "numVector", numVector_c0 );
    
    Jarr strVector_c0;
    for ( int strVector_i0 = 0 ; strVector_i0 < p->strVector.size() ; strVector_i0++ )
    {
        auto& strVector_e0 = p->strVector[strVector_i0];
        strVector_c0.push_back( strVector_e0 );
    }
    PUM::Push( obj, "strVector", strVector_c0 );
    
    Jarr baseVec_c0;
    for ( int baseVec_i0 = 0 ; baseVec_i0 < p->baseVec.size() ; baseVec_i0++ )
    {
        auto& baseVec_e0 = p->baseVec[baseVec_i0];
        Jobj baseVec_e0_obj;
        auto& baseVec_e0_value = baseVec_e0;
        auto baseVec_e0_ptr = &baseVec_e0_value;
        if ( baseVec_e0_ptr )
        {
            _Serialize( baseVec_e0_ptr, baseVec_e0_obj );
            baseVec_c0.push_back( baseVec_e0_obj );
        }
        else
            baseVec_c0.push_back( nullptr );
    }
    PUM::Push( obj, "baseVec", baseVec_c0 );
    
    Jarr basePtrVec_c0;
    for ( int basePtrVec_i0 = 0 ; basePtrVec_i0 < p->basePtrVec.size() ; basePtrVec_i0++ )
    {
        auto& basePtrVec_e0 = p->basePtrVec[basePtrVec_i0];
        Jobj basePtrVec_e0_obj;
        auto& basePtrVec_e0_value = basePtrVec_e0;
        auto basePtrVec_e0_ptr = basePtrVec_e0_value;
        if ( basePtrVec_e0_ptr )
        {
            _Serialize( basePtrVec_e0_ptr, basePtrVec_e0_obj );
            basePtrVec_c0.push_back( basePtrVec_e0_obj );
        }
        else
            basePtrVec_c0.push_back( nullptr );
    }
    PUM::Push( obj, "basePtrVec", basePtrVec_c0 );
    
    Jarr baseSPVec_c0;
    for ( int baseSPVec_i0 = 0 ; baseSPVec_i0 < p->baseSPVec.size() ; baseSPVec_i0++ )
    {
        auto& baseSPVec_e0 = p->baseSPVec[baseSPVec_i0];
        Jobj baseSPVec_e0_obj;
        auto& baseSPVec_e0_value = baseSPVec_e0;
        auto baseSPVec_e0_ptr = baseSPVec_e0_value.get();
        if ( baseSPVec_e0_ptr )
        {
            _Serialize( baseSPVec_e0_ptr, baseSPVec_e0_obj );
            baseSPVec_c0.push_back( baseSPVec_e0_obj );
        }
        else
            baseSPVec_c0.push_back( nullptr );
    }
    PUM::Push( obj, "baseSPVec", baseSPVec_c0 );
    
    Jobj intIntMap_c0;
    for ( auto& intIntMap_e0 : p->intIntMap )
    {
        intIntMap_c0.insert( { PUM::ConvertToString( intIntMap_e0.first ), intIntMap_e0.second } );
    }
    PUM::PushMap( obj, "intIntMap", intIntMap_c0 );
    
    Jobj intBoolMap_c0;
    for ( auto& intBoolMap_e0 : p->intBoolMap )
    {
        intBoolMap_c0.insert( { PUM::ConvertToString( intBoolMap_e0.first ), intBoolMap_e0.second } );
    }
    PUM::PushMap( obj, "intBoolMap", intBoolMap_c0 );
    
    Jobj intStrMap_c0;
    for ( auto& intStrMap_e0 : p->intStrMap )
    {
        intStrMap_c0.insert( { PUM::ConvertToString( intStrMap_e0.first ), intStrMap_e0.second } );
    }
    PUM::PushMap( obj, "intStrMap", intStrMap_c0 );
    
    Jobj strStrMap_c0;
    for ( auto& strStrMap_e0 : p->strStrMap )
    {
        strStrMap_c0.insert( { PUM::ConvertToString( strStrMap_e0.first ), strStrMap_e0.second } );
    }
    PUM::PushMap( obj, "strStrMap", strStrMap_c0 );
    
    Jobj strIntMap_c0;
    for ( auto& strIntMap_e0 : p->strIntMap )
    {
        strIntMap_c0.insert( { PUM::ConvertToString( strIntMap_e0.first ), strIntMap_e0.second } );
    }
    PUM::PushMap( obj, "strIntMap", strIntMap_c0 );
    
    Jobj strBoolMap_c0;
    for ( auto& strBoolMap_e0 : p->strBoolMap )
    {
        strBoolMap_c0.insert( { PUM::ConvertToString( strBoolMap_e0.first ), strBoolMap_e0.second } );
    }
    PUM::PushMap( obj, "strBoolMap", strBoolMap_c0 );
    
    Jobj strBaseMap_c0;
    for ( auto& strBaseMap_e0 : p->strBaseMap )
    {
        Jobj strBaseMap_e0_obj;
        auto& strBaseMap_e0_value = strBaseMap_e0.second;
        auto strBaseMap_e0_ptr = &strBaseMap_e0_value;
        if ( strBaseMap_e0_ptr )
        {
            _Serialize( strBaseMap_e0_ptr, strBaseMap_e0_obj );
            strBaseMap_c0.insert( { PUM::ConvertToString( strBaseMap_e0.first ), strBaseMap_e0_obj } );
        }
        else
            strBaseMap_c0.insert( { PUM::ConvertToString( strBaseMap_e0.first ), nullptr } );
    }
    PUM::PushMap( obj, "strBaseMap", strBaseMap_c0 );
    
    Jobj strBasePtrMap_c0;
    for ( auto& strBasePtrMap_e0 : p->strBasePtrMap )
    {
        Jobj strBasePtrMap_e0_obj;
        auto& strBasePtrMap_e0_value = strBasePtrMap_e0.second;
        auto strBasePtrMap_e0_ptr = strBasePtrMap_e0_value;
        if ( strBasePtrMap_e0_ptr )
        {
            _Serialize( strBasePtrMap_e0_ptr, strBasePtrMap_e0_obj );
            strBasePtrMap_c0.insert( { PUM::ConvertToString( strBasePtrMap_e0.first ), strBasePtrMap_e0_obj } );
        }
        else
            strBasePtrMap_c0.insert( { PUM::ConvertToString( strBasePtrMap_e0.first ), nullptr } );
    }
    PUM::PushMap( obj, "strBasePtrMap", strBasePtrMap_c0 );
    
    Jobj strBaseSPMap_c0;
    for ( auto& strBaseSPMap_e0 : p->strBaseSPMap )
    {
        Jobj strBaseSPMap_e0_obj;
        auto& strBaseSPMap_e0_value = strBaseSPMap_e0.second;
        auto strBaseSPMap_e0_ptr = strBaseSPMap_e0_value.get();
        if ( strBaseSPMap_e0_ptr )
        {
            _Serialize( strBaseSPMap_e0_ptr, strBaseSPMap_e0_obj );
            strBaseSPMap_c0.insert( { PUM::ConvertToString( strBaseSPMap_e0.first ), strBaseSPMap_e0_obj } );
        }
        else
            strBaseSPMap_c0.insert( { PUM::ConvertToString( strBaseSPMap_e0.first ), nullptr } );
    }
    PUM::PushMap( obj, "strBaseSPMap", strBaseSPMap_c0 );
    
    Jobj intBaseMap_c0;
    for ( auto& intBaseMap_e0 : p->intBaseMap )
    {
        Jobj intBaseMap_e0_obj;
        auto& intBaseMap_e0_value = intBaseMap_e0.second;
        auto intBaseMap_e0_ptr = &intBaseMap_e0_value;
        if ( intBaseMap_e0_ptr )
        {
            _Serialize( intBaseMap_e0_ptr, intBaseMap_e0_obj );
            intBaseMap_c0.insert( { PUM::ConvertToString( intBaseMap_e0.first ), intBaseMap_e0_obj } );
        }
        else
            intBaseMap_c0.insert( { PUM::ConvertToString( intBaseMap_e0.first ), nullptr } );
    }
    PUM::PushMap( obj, "intBaseMap", intBaseMap_c0 );
    
    Jobj intBasePtrMap_c0;
    for ( auto& intBasePtrMap_e0 : p->intBasePtrMap )
    {
        Jobj intBasePtrMap_e0_obj;
        auto& intBasePtrMap_e0_value = intBasePtrMap_e0.second;
        auto intBasePtrMap_e0_ptr = intBasePtrMap_e0_value;
        if ( intBasePtrMap_e0_ptr )
        {
            _Serialize( intBasePtrMap_e0_ptr, intBasePtrMap_e0_obj );
            intBasePtrMap_c0.insert( { PUM::ConvertToString( intBasePtrMap_e0.first ), intBasePtrMap_e0_obj } );
        }
        else
            intBasePtrMap_c0.insert( { PUM::ConvertToString( intBasePtrMap_e0.first ), nullptr } );
    }
    PUM::PushMap( obj, "intBasePtrMap", intBasePtrMap_c0 );
    
    Jobj intBaseSPMap_c0;
    for ( auto& intBaseSPMap_e0 : p->intBaseSPMap )
    {
        Jobj intBaseSPMap_e0_obj;
        auto& intBaseSPMap_e0_value = intBaseSPMap_e0.second;
        auto intBaseSPMap_e0_ptr = intBaseSPMap_e0_value.get();
        if ( intBaseSPMap_e0_ptr )
        {
            _Serialize( intBaseSPMap_e0_ptr, intBaseSPMap_e0_obj );
            intBaseSPMap_c0.insert( { PUM::ConvertToString( intBaseSPMap_e0.first ), intBaseSPMap_e0_obj } );
        }
        else
            intBaseSPMap_c0.insert( { PUM::ConvertToString( intBaseSPMap_e0.first ), nullptr } );
    }
    PUM::PushMap( obj, "intBaseSPMap", intBaseSPMap_c0 );
    
    Jarr intArrArr_c0;
    for ( int intArrArr_i0 = 0 ; intArrArr_i0 < p->intArrArr.size() ; intArrArr_i0++ )
    {
        auto& intArrArr_e0 = p->intArrArr[intArrArr_i0];
        Jarr intArrArr_c1;
        for ( int intArrArr_i1 = 0 ; intArrArr_i1 < intArrArr_e0.size() ; intArrArr_i1++ )
        {
            auto& intArrArr_e1 = intArrArr_e0[intArrArr_i1];
            intArrArr_c1.push_back( intArrArr_e1 );
        }
        intArrArr_c0.push_back( intArrArr_c1 );
    }
    PUM::Push( obj, "intArrArr", intArrArr_c0 );
    
    Jarr strArrArr_c0;
    for ( int strArrArr_i0 = 0 ; strArrArr_i0 < p->strArrArr.size() ; strArrArr_i0++ )
    {
        auto& strArrArr_e0 = p->strArrArr[strArrArr_i0];
        Jarr strArrArr_c1;
        for ( int strArrArr_i1 = 0 ; strArrArr_i1 < strArrArr_e0.size() ; strArrArr_i1++ )
        {
            auto& strArrArr_e1 = strArrArr_e0[strArrArr_i1];
            strArrArr_c1.push_back( strArrArr_e1 );
        }
        strArrArr_c0.push_back( strArrArr_c1 );
    }
    PUM::Push( obj, "strArrArr", strArrArr_c0 );
    
    Jobj strArrMap_c0;
    for ( auto& strArrMap_e0 : p->strArrMap )
    {
        Jarr strArrMap_c1;
        for ( int strArrMap_i1 = 0 ; strArrMap_i1 < strArrMap_e0.second.size() ; strArrMap_i1++ )
        {
            auto& strArrMap_e1 = strArrMap_e0.second[strArrMap_i1];
            strArrMap_c1.push_back( strArrMap_e1 );
        }
        strArrMap_c0.insert( { PUM::ConvertToString( strArrMap_e0.first ), strArrMap_c1 } );
    }
    PUM::PushMap( obj, "strArrMap", strArrMap_c0 );
    
    Jarr strMapArr_c0;
    for ( int strMapArr_i0 = 0 ; strMapArr_i0 < p->strMapArr.size() ; strMapArr_i0++ )
    {
        auto& strMapArr_e0 = p->strMapArr[strMapArr_i0];
        Jobj strMapArr_c1;
        for ( auto& strMapArr_e1 : strMapArr_e0 )
        {
            strMapArr_c1.insert( { PUM::ConvertToString( strMapArr_e1.first ), strMapArr_e1.second } );
        }
        strMapArr_c0.push_back( strMapArr_c1 );
    }
    PUM::Push( obj, "strMapArr", strMapArr_c0 );
    
    Jobj strMapMap_c0;
    for ( auto& strMapMap_e0 : p->strMapMap )
    {
        Jobj strMapMap_c1;
        for ( auto& strMapMap_e1 : strMapMap_e0.second )
        {
            strMapMap_c1.insert( { PUM::ConvertToString( strMapMap_e1.first ), strMapMap_e1.second } );
        }
        strMapMap_c0.insert( { PUM::ConvertToString( strMapMap_e0.first ), strMapMap_c1 } );
    }
    PUM::PushMap( obj, "strMapMap", strMapMap_c0 );
    
    Jarr objArrArr_c0;
    for ( int objArrArr_i0 = 0 ; objArrArr_i0 < p->objArrArr.size() ; objArrArr_i0++ )
    {
        auto& objArrArr_e0 = p->objArrArr[objArrArr_i0];
        Jarr objArrArr_c1;
        for ( int objArrArr_i1 = 0 ; objArrArr_i1 < objArrArr_e0.size() ; objArrArr_i1++ )
        {
            auto& objArrArr_e1 = objArrArr_e0[objArrArr_i1];
            Jobj objArrArr_e1_obj;
            auto& objArrArr_e1_value = objArrArr_e1;
            auto objArrArr_e1_ptr = &objArrArr_e1_value;
            if ( objArrArr_e1_ptr )
            {
                _Serialize( objArrArr_e1_ptr, objArrArr_e1_obj );
                objArrArr_c1.push_back( objArrArr_e1_obj );
            }
            else
                objArrArr_c1.push_back( nullptr );
        }
        objArrArr_c0.push_back( objArrArr_c1 );
    }
    PUM::Push( obj, "objArrArr", objArrArr_c0 );
    
    Jarr ptrObjArrArr_c0;
    for ( int ptrObjArrArr_i0 = 0 ; ptrObjArrArr_i0 < p->ptrObjArrArr.size() ; ptrObjArrArr_i0++ )
    {
        auto& ptrObjArrArr_e0 = p->ptrObjArrArr[ptrObjArrArr_i0];
        Jarr ptrObjArrArr_c1;
        for ( int ptrObjArrArr_i1 = 0 ; ptrObjArrArr_i1 < ptrObjArrArr_e0.size() ; ptrObjArrArr_i1++ )
        {
            auto& ptrObjArrArr_e1 = ptrObjArrArr_e0[ptrObjArrArr_i1];
            Jobj ptrObjArrArr_e1_obj;
            auto& ptrObjArrArr_e1_value = ptrObjArrArr_e1;
            auto ptrObjArrArr_e1_ptr = ptrObjArrArr_e1_value;
            if ( ptrObjArrArr_e1_ptr )
            {
                _Serialize( ptrObjArrArr_e1_ptr, ptrObjArrArr_e1_obj );
                ptrObjArrArr_c1.push_back( ptrObjArrArr_e1_obj );
            }
            else
                ptrObjArrArr_c1.push_back( nullptr );
        }
        ptrObjArrArr_c0.push_back( ptrObjArrArr_c1 );
    }
    PUM::Push( obj, "ptrObjArrArr", ptrObjArrArr_c0 );
    
    Jarr spObjArrArr_c0;
    for ( int spObjArrArr_i0 = 0 ; spObjArrArr_i0 < p->spObjArrArr.size() ; spObjArrArr_i0++ )
    {
        auto& spObjArrArr_e0 = p->spObjArrArr[spObjArrArr_i0];
        Jarr spObjArrArr_c1;
        for ( int spObjArrArr_i1 = 0 ; spObjArrArr_i1 < spObjArrArr_e0.size() ; spObjArrArr_i1++ )
        {
            auto& spObjArrArr_e1 = spObjArrArr_e0[spObjArrArr_i1];
            Jobj spObjArrArr_e1_obj;
            auto& spObjArrArr_e1_value = spObjArrArr_e1;
            auto spObjArrArr_e1_ptr = spObjArrArr_e1_value.get();
            if ( spObjArrArr_e1_ptr )
            {
                _Serialize( spObjArrArr_e1_ptr, spObjArrArr_e1_obj );
                spObjArrArr_c1.push_back( spObjArrArr_e1_obj );
            }
            else
                spObjArrArr_c1.push_back( nullptr );
        }
        spObjArrArr_c0.push_back( spObjArrArr_c1 );
    }
    PUM::Push( obj, "spObjArrArr", spObjArrArr_c0 );
    
    Jarr objMapArr_c0;
    for ( int objMapArr_i0 = 0 ; objMapArr_i0 < p->objMapArr.size() ; objMapArr_i0++ )
    {
        auto& objMapArr_e0 = p->objMapArr[objMapArr_i0];
        Jobj objMapArr_c1;
        for ( auto& objMapArr_e1 : objMapArr_e0 )
        {
            Jobj objMapArr_e1_obj;
            auto& objMapArr_e1_value = objMapArr_e1.second;
            auto objMapArr_e1_ptr = &objMapArr_e1_value;
            if ( objMapArr_e1_ptr )
            {
                _Serialize( objMapArr_e1_ptr, objMapArr_e1_obj );
                objMapArr_c1.insert( { PUM::ConvertToString( objMapArr_e1.first ), objMapArr_e1_obj } );
            }
            else
                objMapArr_c1.insert( { PUM::ConvertToString( objMapArr_e1.first ), nullptr } );
        }
        objMapArr_c0.push_back( objMapArr_c1 );
    }
    PUM::Push( obj, "objMapArr", objMapArr_c0 );
    
    Jarr ptrObjMapArr_c0;
    for ( int ptrObjMapArr_i0 = 0 ; ptrObjMapArr_i0 < p->ptrObjMapArr.size() ; ptrObjMapArr_i0++ )
    {
        auto& ptrObjMapArr_e0 = p->ptrObjMapArr[ptrObjMapArr_i0];
        Jobj ptrObjMapArr_c1;
        for ( auto& ptrObjMapArr_e1 : ptrObjMapArr_e0 )
        {
            Jobj ptrObjMapArr_e1_obj;
            auto& ptrObjMapArr_e1_value = ptrObjMapArr_e1.second;
            auto ptrObjMapArr_e1_ptr = ptrObjMapArr_e1_value;
            if ( ptrObjMapArr_e1_ptr )
            {
                _Serialize( ptrObjMapArr_e1_ptr, ptrObjMapArr_e1_obj );
                ptrObjMapArr_c1.insert( { PUM::ConvertToString( ptrObjMapArr_e1.first ), ptrObjMapArr_e1_obj } );
            }
            else
                ptrObjMapArr_c1.insert( { PUM::ConvertToString( ptrObjMapArr_e1.first ), nullptr } );
        }
        ptrObjMapArr_c0.push_back( ptrObjMapArr_c1 );
    }
    PUM::Push( obj, "ptrObjMapArr", ptrObjMapArr_c0 );
    
    Jarr spObjMapArr_c0;
    for ( int spObjMapArr_i0 = 0 ; spObjMapArr_i0 < p->spObjMapArr.size() ; spObjMapArr_i0++ )
    {
        auto& spObjMapArr_e0 = p->spObjMapArr[spObjMapArr_i0];
        Jobj spObjMapArr_c1;
        for ( auto& spObjMapArr_e1 : spObjMapArr_e0 )
        {
            Jobj spObjMapArr_e1_obj;
            auto& spObjMapArr_e1_value = spObjMapArr_e1.second;
            auto spObjMapArr_e1_ptr = spObjMapArr_e1_value.get();
            if ( spObjMapArr_e1_ptr )
            {
                _Serialize( spObjMapArr_e1_ptr, spObjMapArr_e1_obj );
                spObjMapArr_c1.insert( { PUM::ConvertToString( spObjMapArr_e1.first ), spObjMapArr_e1_obj } );
            }
            else
                spObjMapArr_c1.insert( { PUM::ConvertToString( spObjMapArr_e1.first ), nullptr } );
        }
        spObjMapArr_c0.push_back( spObjMapArr_c1 );
    }
    PUM::Push( obj, "spObjMapArr", spObjMapArr_c0 );
    
    Jobj objMapMap_c0;
    for ( auto& objMapMap_e0 : p->objMapMap )
    {
        Jobj objMapMap_c1;
        for ( auto& objMapMap_e1 : objMapMap_e0.second )
        {
            Jobj objMapMap_e1_obj;
            auto& objMapMap_e1_value = objMapMap_e1.second;
            auto objMapMap_e1_ptr = &objMapMap_e1_value;
            if ( objMapMap_e1_ptr )
            {
                _Serialize( objMapMap_e1_ptr, objMapMap_e1_obj );
                objMapMap_c1.insert( { PUM::ConvertToString( objMapMap_e1.first ), objMapMap_e1_obj } );
            }
            else
                objMapMap_c1.insert( { PUM::ConvertToString( objMapMap_e1.first ), nullptr } );
        }
        objMapMap_c0.insert( { PUM::ConvertToString( objMapMap_e0.first ), objMapMap_c1 } );
    }
    PUM::PushMap( obj, "objMapMap", objMapMap_c0 );
    
    Jobj ptrObjMapMap_c0;
    for ( auto& ptrObjMapMap_e0 : p->ptrObjMapMap )
    {
        Jobj ptrObjMapMap_c1;
        for ( auto& ptrObjMapMap_e1 : ptrObjMapMap_e0.second )
        {
            Jobj ptrObjMapMap_e1_obj;
            auto& ptrObjMapMap_e1_value = ptrObjMapMap_e1.second;
            auto ptrObjMapMap_e1_ptr = ptrObjMapMap_e1_value;
            if ( ptrObjMapMap_e1_ptr )
            {
                _Serialize( ptrObjMapMap_e1_ptr, ptrObjMapMap_e1_obj );
                ptrObjMapMap_c1.insert( { PUM::ConvertToString( ptrObjMapMap_e1.first ), ptrObjMapMap_e1_obj } );
            }
            else
                ptrObjMapMap_c1.insert( { PUM::ConvertToString( ptrObjMapMap_e1.first ), nullptr } );
        }
        ptrObjMapMap_c0.insert( { PUM::ConvertToString( ptrObjMapMap_e0.first ), ptrObjMapMap_c1 } );
    }
    PUM::PushMap( obj, "ptrObjMapMap", ptrObjMapMap_c0 );
    
    Jobj spObjMapMap_c0;
    for ( auto& spObjMapMap_e0 : p->spObjMapMap )
    {
        Jobj spObjMapMap_c1;
        for ( auto& spObjMapMap_e1 : spObjMapMap_e0.second )
        {
            Jobj spObjMapMap_e1_obj;
            auto& spObjMapMap_e1_value = spObjMapMap_e1.second;
            auto spObjMapMap_e1_ptr = spObjMapMap_e1_value.get();
            if ( spObjMapMap_e1_ptr )
            {
                _Serialize( spObjMapMap_e1_ptr, spObjMapMap_e1_obj );
                spObjMapMap_c1.insert( { PUM::ConvertToString( spObjMapMap_e1.first ), spObjMapMap_e1_obj } );
            }
            else
                spObjMapMap_c1.insert( { PUM::ConvertToString( spObjMapMap_e1.first ), nullptr } );
        }
        spObjMapMap_c0.insert( { PUM::ConvertToString( spObjMapMap_e0.first ), spObjMapMap_c1 } );
    }
    PUM::PushMap( obj, "spObjMapMap", spObjMapMap_c0 );
    
    Jobj colossalMember_c0;
    for ( auto& colossalMember_e0 : p->colossalMember )
    {
        Jarr colossalMember_c1;
        for ( int colossalMember_i1 = 0 ; colossalMember_i1 < colossalMember_e0.second.size() ; colossalMember_i1++ )
        {
            auto& colossalMember_e1 = colossalMember_e0.second[colossalMember_i1];
            Jobj colossalMember_c2;
            for ( auto& colossalMember_e2 : colossalMember_e1 )
            {
                Jarr colossalMember_c3;
                for ( int colossalMember_i3 = 0 ; colossalMember_i3 < colossalMember_e2.second.size() ; colossalMember_i3++ )
                {
                    auto& colossalMember_e3 = colossalMember_e2.second[colossalMember_i3];
                    Jobj colossalMember_c4;
                    for ( auto& colossalMember_e4 : colossalMember_e3 )
                    {
                        Jobj colossalMember_c5;
                        for ( auto& colossalMember_e5 : colossalMember_e4.second )
                        {
                            Jarr colossalMember_c6;
                            for ( int colossalMember_i6 = 0 ; colossalMember_i6 < colossalMember_e5.second.size() ; colossalMember_i6++ )
                            {
                                auto& colossalMember_e6 = colossalMember_e5.second[colossalMember_i6];
                                Jarr colossalMember_c7;
                                for ( int colossalMember_i7 = 0 ; colossalMember_i7 < colossalMember_e6.size() ; colossalMember_i7++ )
                                {
                                    auto& colossalMember_e7 = colossalMember_e6[colossalMember_i7];
                                    colossalMember_c7.push_back( colossalMember_e7 );
                                }
                                colossalMember_c6.push_back( colossalMember_c7 );
                            }
                            colossalMember_c5.insert( { PUM::ConvertToString( colossalMember_e5.first ), colossalMember_c6 } );
                        }
                        colossalMember_c4.insert( { PUM::ConvertToString( colossalMember_e4.first ), colossalMember_c5 } );
                    }
                    colossalMember_c3.push_back( colossalMember_c4 );
                }
                colossalMember_c2.insert( { PUM::ConvertToString( colossalMember_e2.first ), colossalMember_c3 } );
            }
            colossalMember_c1.push_back( colossalMember_c2 );
        }
        colossalMember_c0.insert( { PUM::ConvertToString( colossalMember_e0.first ), colossalMember_c1 } );
    }
    PUM::PushMap( obj, "colossalMember", colossalMember_c0 );
    
    Jobj intSuperMap_c0;
    for ( auto& intSuperMap_e0 : p->intSuperMap )
    {
        Jobj intSuperMap_c1;
        for ( auto& intSuperMap_e1 : intSuperMap_e0.second )
        {
            Jobj intSuperMap_c2;
            for ( auto& intSuperMap_e2 : intSuperMap_e1.second )
            {
                Jobj intSuperMap_c3;
                for ( auto& intSuperMap_e3 : intSuperMap_e2.second )
                {
                    intSuperMap_c3.insert( { PUM::ConvertToString( intSuperMap_e3.first ), intSuperMap_e3.second } );
                }
                intSuperMap_c2.insert( { PUM::ConvertToString( intSuperMap_e2.first ), intSuperMap_c3 } );
            }
            intSuperMap_c1.insert( { PUM::ConvertToString( intSuperMap_e1.first ), intSuperMap_c2 } );
        }
        intSuperMap_c0.insert( { PUM::ConvertToString( intSuperMap_e0.first ), intSuperMap_c1 } );
    }
    PUM::PushMap( obj, "intSuperMap", intSuperMap_c0 );
    
    Jarr intSuperVec_c0;
    for ( int intSuperVec_i0 = 0 ; intSuperVec_i0 < p->intSuperVec.size() ; intSuperVec_i0++ )
    {
        auto& intSuperVec_e0 = p->intSuperVec[intSuperVec_i0];
        Jarr intSuperVec_c1;
        for ( int intSuperVec_i1 = 0 ; intSuperVec_i1 < intSuperVec_e0.size() ; intSuperVec_i1++ )
        {
            auto& intSuperVec_e1 = intSuperVec_e0[intSuperVec_i1];
            Jarr intSuperVec_c2;
            for ( int intSuperVec_i2 = 0 ; intSuperVec_i2 < intSuperVec_e1.size() ; intSuperVec_i2++ )
            {
                auto& intSuperVec_e2 = intSuperVec_e1[intSuperVec_i2];
                Jarr intSuperVec_c3;
                for ( int intSuperVec_i3 = 0 ; intSuperVec_i3 < intSuperVec_e2.size() ; intSuperVec_i3++ )
                {
                    auto& intSuperVec_e3 = intSuperVec_e2[intSuperVec_i3];
                    intSuperVec_c3.push_back( intSuperVec_e3 );
                }
                intSuperVec_c2.push_back( intSuperVec_c3 );
            }
            intSuperVec_c1.push_back( intSuperVec_c2 );
        }
        intSuperVec_c0.push_back( intSuperVec_c1 );
    }
    PUM::Push( obj, "intSuperVec", intSuperVec_c0 );
    
    Jarr boolSuperList_c0;
    for ( auto& boolSuperList_e0 : p->boolSuperList )
    {
        Jarr boolSuperList_c1;
        for ( auto& boolSuperList_e1 : boolSuperList_e0 )
        {
            Jarr boolSuperList_c2;
            for ( auto& boolSuperList_e2 : boolSuperList_e1 )
            {
                Jarr boolSuperList_c3;
                for ( auto& boolSuperList_e3 : boolSuperList_e2 )
                {
                    boolSuperList_c3.push_back( boolSuperList_e3 );
                }
                boolSuperList_c2.push_back( boolSuperList_c3 );
            }
            boolSuperList_c1.push_back( boolSuperList_c2 );
        }
        boolSuperList_c0.push_back( boolSuperList_c1 );
    }
    PUM::Push( obj, "boolSuperList", boolSuperList_c0 );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsBS::TTestStruct* p, const json11::Json& json )
{
    _Deserialize( (nsBS::TBaseStruct*)p, json);
    auto& baseStruct_json = json["baseStruct"];
    _Deserialize( &(p->baseStruct), baseStruct_json );
    auto& pBaseStruct_json = json["pBaseStruct"];
    if ( pBaseStruct_json.is_null() == false )
    {
        if ( p->pBaseStruct == nullptr )
            p->pBaseStruct = new nsBS::TBaseStruct();
        _Deserialize( p->pBaseStruct, pBaseStruct_json );
    }
    auto& spBaseStruct_json = json["spBaseStruct"];
    if ( spBaseStruct_json.is_null() == false )
    {
        if ( p->spBaseStruct.get() == nullptr )
            p->spBaseStruct.reset( new nsBS::TBaseStruct() );
        _Deserialize( p->spBaseStruct.get(), spBaseStruct_json );
    }
    POM::PopStr( json, "password", p->password );
    POM::PopNum( json, "port", p->port );
    POM::PopBool( json, "flag", p->flag );
    POM::PopStrSet( json, "strSet", p->strSet );
    POM::PopNumSet<int>( json, "intSet", p->intSet );
    
    auto& boolList_src0 = json["boolList"].array_items();
    for ( auto& boolList_e0 : boolList_src0 )
    {
        p->boolList.push_back( boolList_e0.bool_value() );
    }
    
    auto& numList_src0 = json["numList"].array_items();
    for ( auto& numList_e0 : numList_src0 )
    {
        p->numList.push_back( (int)(numList_e0.number_value()) );
    }
    
    auto& numVector_src0 = json["numVector"].array_items();
    for ( auto& numVector_e0 : numVector_src0 )
    {
        p->numVector.push_back( (int)(numVector_e0.number_value()) );
    }
    
    auto& strVector_src0 = json["strVector"].array_items();
    for ( auto& strVector_e0 : strVector_src0 )
    {
        p->strVector.push_back( strVector_e0.string_value() );
    }
    
    auto& baseVec_src0 = json["baseVec"].array_items();
    for ( auto& baseVec_e0 : baseVec_src0 )
    {
        auto& first_e0 = baseVec_e0;
        nsBS::TBaseStruct baseVec_newObj0;
        if ( first_e0.is_null() == false )
        {
            _Deserialize( &baseVec_newObj0, first_e0 );
        }
        p->baseVec.push_back( baseVec_newObj0 );
    }
    
    auto& basePtrVec_src0 = json["basePtrVec"].array_items();
    for ( auto& basePtrVec_e0 : basePtrVec_src0 )
    {
        auto& first_e0 = basePtrVec_e0;
        nsBS::TBaseStruct* basePtrVec_newObj0 = nullptr;
        if ( first_e0.is_null() == false )
        {
            basePtrVec_newObj0 = new nsBS::TBaseStruct();
            _Deserialize( basePtrVec_newObj0, first_e0 );
        }
        p->basePtrVec.push_back( basePtrVec_newObj0 );
    }
    
    auto& baseSPVec_src0 = json["baseSPVec"].array_items();
    for ( auto& baseSPVec_e0 : baseSPVec_src0 )
    {
        auto& first_e0 = baseSPVec_e0;
        std::shared_ptr<nsBS::TBaseStruct> baseSPVec_newObj0;
        if ( first_e0.is_null() == false )
        {
            baseSPVec_newObj0.reset( new nsBS::TBaseStruct() );
            _Deserialize( baseSPVec_newObj0.get(), first_e0 );
        }
        p->baseSPVec.push_back( baseSPVec_newObj0 );
    }
    
    auto& intIntMap_src0 = json["intIntMap"].object_items();
    for ( auto& intIntMap_e0 : intIntMap_src0 )
    {
        p->intIntMap.insert( { (int)(std::stod( intIntMap_e0.first )), (int)(intIntMap_e0.second.number_value()) } );
    }
    
    auto& intBoolMap_src0 = json["intBoolMap"].object_items();
    for ( auto& intBoolMap_e0 : intBoolMap_src0 )
    {
        p->intBoolMap.insert( { (int)(std::stod( intBoolMap_e0.first )), intBoolMap_e0.second.bool_value() } );
    }
    
    auto& intStrMap_src0 = json["intStrMap"].object_items();
    for ( auto& intStrMap_e0 : intStrMap_src0 )
    {
        p->intStrMap.insert( { (int)(std::stod( intStrMap_e0.first )), intStrMap_e0.second.string_value() } );
    }
    
    auto& strStrMap_src0 = json["strStrMap"].object_items();
    for ( auto& strStrMap_e0 : strStrMap_src0 )
    {
        p->strStrMap.insert( { strStrMap_e0.first, strStrMap_e0.second.string_value() } );
    }
    
    auto& strIntMap_src0 = json["strIntMap"].object_items();
    for ( auto& strIntMap_e0 : strIntMap_src0 )
    {
        p->strIntMap.insert( { strIntMap_e0.first, (int)(strIntMap_e0.second.number_value()) } );
    }
    
    auto& strBoolMap_src0 = json["strBoolMap"].object_items();
    for ( auto& strBoolMap_e0 : strBoolMap_src0 )
    {
        p->strBoolMap.insert( { strBoolMap_e0.first, strBoolMap_e0.second.bool_value() } );
    }
    
    auto& strBaseMap_src0 = json["strBaseMap"].object_items();
    for ( auto& strBaseMap_e0 : strBaseMap_src0 )
    {
        auto& first_e0 = strBaseMap_e0.first;
        auto& second_e0 = strBaseMap_e0.second;
        nsBS::TBaseStruct strBaseMap_newObj0;
        if ( second_e0.is_null() == false )
        {
            _Deserialize( &strBaseMap_newObj0, second_e0 );
        }
        p->strBaseMap.insert( { strBaseMap_e0.first, strBaseMap_newObj0 } );
    }
    
    auto& strBasePtrMap_src0 = json["strBasePtrMap"].object_items();
    for ( auto& strBasePtrMap_e0 : strBasePtrMap_src0 )
    {
        auto& first_e0 = strBasePtrMap_e0.first;
        auto& second_e0 = strBasePtrMap_e0.second;
        nsBS::TBaseStruct* strBasePtrMap_newObj0 = nullptr;
        if ( second_e0.is_null() == false )
        {
            strBasePtrMap_newObj0 = new nsBS::TBaseStruct();
            _Deserialize( strBasePtrMap_newObj0, second_e0 );
        }
        p->strBasePtrMap.insert( { strBasePtrMap_e0.first, strBasePtrMap_newObj0 } );
    }
    
    auto& strBaseSPMap_src0 = json["strBaseSPMap"].object_items();
    for ( auto& strBaseSPMap_e0 : strBaseSPMap_src0 )
    {
        auto& first_e0 = strBaseSPMap_e0.first;
        auto& second_e0 = strBaseSPMap_e0.second;
        std::shared_ptr<nsBS::TBaseStruct> strBaseSPMap_newObj0;
        if ( second_e0.is_null() == false )
        {
            strBaseSPMap_newObj0.reset( new nsBS::TBaseStruct() );
            _Deserialize( strBaseSPMap_newObj0.get(), second_e0 );
        }
        p->strBaseSPMap.insert( { strBaseSPMap_e0.first, strBaseSPMap_newObj0 } );
    }
    
    auto& intBaseMap_src0 = json["intBaseMap"].object_items();
    for ( auto& intBaseMap_e0 : intBaseMap_src0 )
    {
        auto& first_e0 = intBaseMap_e0.first;
        auto& second_e0 = intBaseMap_e0.second;
        nsBS::TBaseStruct intBaseMap_newObj0;
        if ( second_e0.is_null() == false )
        {
            _Deserialize( &intBaseMap_newObj0, second_e0 );
        }
        p->intBaseMap.insert( { (int)(std::stod( intBaseMap_e0.first )), intBaseMap_newObj0 } );
    }
    
    auto& intBasePtrMap_src0 = json["intBasePtrMap"].object_items();
    for ( auto& intBasePtrMap_e0 : intBasePtrMap_src0 )
    {
        auto& first_e0 = intBasePtrMap_e0.first;
        auto& second_e0 = intBasePtrMap_e0.second;
        nsBS::TBaseStruct* intBasePtrMap_newObj0 = nullptr;
        if ( second_e0.is_null() == false )
        {
            intBasePtrMap_newObj0 = new nsBS::TBaseStruct();
            _Deserialize( intBasePtrMap_newObj0, second_e0 );
        }
        p->intBasePtrMap.insert( { (int)(std::stod( intBasePtrMap_e0.first )), intBasePtrMap_newObj0 } );
    }
    
    auto& intBaseSPMap_src0 = json["intBaseSPMap"].object_items();
    for ( auto& intBaseSPMap_e0 : intBaseSPMap_src0 )
    {
        auto& first_e0 = intBaseSPMap_e0.first;
        auto& second_e0 = intBaseSPMap_e0.second;
        std::shared_ptr<nsBS::TBaseStruct> intBaseSPMap_newObj0;
        if ( second_e0.is_null() == false )
        {
            intBaseSPMap_newObj0.reset( new nsBS::TBaseStruct() );
            _Deserialize( intBaseSPMap_newObj0.get(), second_e0 );
        }
        p->intBaseSPMap.insert( { (int)(std::stod( intBaseSPMap_e0.first )), intBaseSPMap_newObj0 } );
    }
    
    auto& intArrArr_src0 = json["intArrArr"].array_items();
    for ( auto& intArrArr_e0 : intArrArr_src0 )
    {
        std::vector<int> intArrArr_c1;
        auto& intArrArr_src1 = intArrArr_e0.array_items();
        for ( auto& intArrArr_e1 : intArrArr_src1 )
        {
            intArrArr_c1.push_back( (int)(intArrArr_e1.number_value()) );
        }
        p->intArrArr.push_back( intArrArr_c1 );
    }
    
    auto& strArrArr_src0 = json["strArrArr"].array_items();
    for ( auto& strArrArr_e0 : strArrArr_src0 )
    {
        std::vector<std::string> strArrArr_c1;
        auto& strArrArr_src1 = strArrArr_e0.array_items();
        for ( auto& strArrArr_e1 : strArrArr_src1 )
        {
            strArrArr_c1.push_back( strArrArr_e1.string_value() );
        }
        p->strArrArr.push_back( strArrArr_c1 );
    }
    
    auto& strArrMap_src0 = json["strArrMap"].object_items();
    for ( auto& strArrMap_e0 : strArrMap_src0 )
    {
        std::vector<std::string> strArrMap_c1;
        auto& strArrMap_src1 = strArrMap_e0.second.array_items();
        for ( auto& strArrMap_e1 : strArrMap_src1 )
        {
            strArrMap_c1.push_back( strArrMap_e1.string_value() );
        }
        p->strArrMap.insert( { strArrMap_e0.first, strArrMap_c1 } );
    }
    
    auto& strMapArr_src0 = json["strMapArr"].array_items();
    for ( auto& strMapArr_e0 : strMapArr_src0 )
    {
        std::map<std::string,std::string> strMapArr_c1;
        auto& strMapArr_src1 = strMapArr_e0.object_items();
        for ( auto& strMapArr_e1 : strMapArr_src1 )
        {
            strMapArr_c1.insert( { strMapArr_e1.first, strMapArr_e1.second.string_value() } );
        }
        p->strMapArr.push_back( strMapArr_c1 );
    }
    
    auto& strMapMap_src0 = json["strMapMap"].object_items();
    for ( auto& strMapMap_e0 : strMapMap_src0 )
    {
        std::map<std::string,std::string> strMapMap_c1;
        auto& strMapMap_src1 = strMapMap_e0.second.object_items();
        for ( auto& strMapMap_e1 : strMapMap_src1 )
        {
            strMapMap_c1.insert( { strMapMap_e1.first, strMapMap_e1.second.string_value() } );
        }
        p->strMapMap.insert( { strMapMap_e0.first, strMapMap_c1 } );
    }
    
    auto& objArrArr_src0 = json["objArrArr"].array_items();
    for ( auto& objArrArr_e0 : objArrArr_src0 )
    {
        std::vector<nsBS::TBaseStruct> objArrArr_c1;
        auto& objArrArr_src1 = objArrArr_e0.array_items();
        for ( auto& objArrArr_e1 : objArrArr_src1 )
        {
            auto& first_e1 = objArrArr_e1;
            nsBS::TBaseStruct objArrArr_newObj1;
            if ( first_e1.is_null() == false )
            {
                _Deserialize( &objArrArr_newObj1, first_e1 );
            }
            objArrArr_c1.push_back( objArrArr_newObj1 );
        }
        p->objArrArr.push_back( objArrArr_c1 );
    }
    
    auto& ptrObjArrArr_src0 = json["ptrObjArrArr"].array_items();
    for ( auto& ptrObjArrArr_e0 : ptrObjArrArr_src0 )
    {
        std::vector<nsBS::TBaseStruct*> ptrObjArrArr_c1;
        auto& ptrObjArrArr_src1 = ptrObjArrArr_e0.array_items();
        for ( auto& ptrObjArrArr_e1 : ptrObjArrArr_src1 )
        {
            auto& first_e1 = ptrObjArrArr_e1;
            nsBS::TBaseStruct* ptrObjArrArr_newObj1 = nullptr;
            if ( first_e1.is_null() == false )
            {
                ptrObjArrArr_newObj1 = new nsBS::TBaseStruct();
                _Deserialize( ptrObjArrArr_newObj1, first_e1 );
            }
            ptrObjArrArr_c1.push_back( ptrObjArrArr_newObj1 );
        }
        p->ptrObjArrArr.push_back( ptrObjArrArr_c1 );
    }
    
    auto& spObjArrArr_src0 = json["spObjArrArr"].array_items();
    for ( auto& spObjArrArr_e0 : spObjArrArr_src0 )
    {
        std::vector<std::shared_ptr<nsBS::TBaseStruct>> spObjArrArr_c1;
        auto& spObjArrArr_src1 = spObjArrArr_e0.array_items();
        for ( auto& spObjArrArr_e1 : spObjArrArr_src1 )
        {
            auto& first_e1 = spObjArrArr_e1;
            std::shared_ptr<nsBS::TBaseStruct> spObjArrArr_newObj1;
            if ( first_e1.is_null() == false )
            {
                spObjArrArr_newObj1.reset( new nsBS::TBaseStruct() );
                _Deserialize( spObjArrArr_newObj1.get(), first_e1 );
            }
            spObjArrArr_c1.push_back( spObjArrArr_newObj1 );
        }
        p->spObjArrArr.push_back( spObjArrArr_c1 );
    }
    
    auto& objMapArr_src0 = json["objMapArr"].array_items();
    for ( auto& objMapArr_e0 : objMapArr_src0 )
    {
        std::map<std::string,nsBS::TBaseStruct> objMapArr_c1;
        auto& objMapArr_src1 = objMapArr_e0.object_items();
        for ( auto& objMapArr_e1 : objMapArr_src1 )
        {
            auto& first_e1 = objMapArr_e1.first;
            auto& second_e1 = objMapArr_e1.second;
            nsBS::TBaseStruct objMapArr_newObj1;
            if ( second_e1.is_null() == false )
            {
                _Deserialize( &objMapArr_newObj1, second_e1 );
            }
            objMapArr_c1.insert( { objMapArr_e1.first, objMapArr_newObj1 } );
        }
        p->objMapArr.push_back( objMapArr_c1 );
    }
    
    auto& ptrObjMapArr_src0 = json["ptrObjMapArr"].array_items();
    for ( auto& ptrObjMapArr_e0 : ptrObjMapArr_src0 )
    {
        std::map<std::string,nsBS::TBaseStruct*> ptrObjMapArr_c1;
        auto& ptrObjMapArr_src1 = ptrObjMapArr_e0.object_items();
        for ( auto& ptrObjMapArr_e1 : ptrObjMapArr_src1 )
        {
            auto& first_e1 = ptrObjMapArr_e1.first;
            auto& second_e1 = ptrObjMapArr_e1.second;
            nsBS::TBaseStruct* ptrObjMapArr_newObj1 = nullptr;
            if ( second_e1.is_null() == false )
            {
                ptrObjMapArr_newObj1 = new nsBS::TBaseStruct();
                _Deserialize( ptrObjMapArr_newObj1, second_e1 );
            }
            ptrObjMapArr_c1.insert( { ptrObjMapArr_e1.first, ptrObjMapArr_newObj1 } );
        }
        p->ptrObjMapArr.push_back( ptrObjMapArr_c1 );
    }
    
    auto& spObjMapArr_src0 = json["spObjMapArr"].array_items();
    for ( auto& spObjMapArr_e0 : spObjMapArr_src0 )
    {
        std::map<std::string,std::shared_ptr<nsBS::TBaseStruct>> spObjMapArr_c1;
        auto& spObjMapArr_src1 = spObjMapArr_e0.object_items();
        for ( auto& spObjMapArr_e1 : spObjMapArr_src1 )
        {
            auto& first_e1 = spObjMapArr_e1.first;
            auto& second_e1 = spObjMapArr_e1.second;
            std::shared_ptr<nsBS::TBaseStruct> spObjMapArr_newObj1;
            if ( second_e1.is_null() == false )
            {
                spObjMapArr_newObj1.reset( new nsBS::TBaseStruct() );
                _Deserialize( spObjMapArr_newObj1.get(), second_e1 );
            }
            spObjMapArr_c1.insert( { spObjMapArr_e1.first, spObjMapArr_newObj1 } );
        }
        p->spObjMapArr.push_back( spObjMapArr_c1 );
    }
    
    auto& objMapMap_src0 = json["objMapMap"].object_items();
    for ( auto& objMapMap_e0 : objMapMap_src0 )
    {
        std::map<std::string,nsBS::TBaseStruct> objMapMap_c1;
        auto& objMapMap_src1 = objMapMap_e0.second.object_items();
        for ( auto& objMapMap_e1 : objMapMap_src1 )
        {
            auto& first_e1 = objMapMap_e1.first;
            auto& second_e1 = objMapMap_e1.second;
            nsBS::TBaseStruct objMapMap_newObj1;
            if ( second_e1.is_null() == false )
            {
                _Deserialize( &objMapMap_newObj1, second_e1 );
            }
            objMapMap_c1.insert( { objMapMap_e1.first, objMapMap_newObj1 } );
        }
        p->objMapMap.insert( { objMapMap_e0.first, objMapMap_c1 } );
    }
    
    auto& ptrObjMapMap_src0 = json["ptrObjMapMap"].object_items();
    for ( auto& ptrObjMapMap_e0 : ptrObjMapMap_src0 )
    {
        std::map<std::string,nsBS::TBaseStruct*> ptrObjMapMap_c1;
        auto& ptrObjMapMap_src1 = ptrObjMapMap_e0.second.object_items();
        for ( auto& ptrObjMapMap_e1 : ptrObjMapMap_src1 )
        {
            auto& first_e1 = ptrObjMapMap_e1.first;
            auto& second_e1 = ptrObjMapMap_e1.second;
            nsBS::TBaseStruct* ptrObjMapMap_newObj1 = nullptr;
            if ( second_e1.is_null() == false )
            {
                ptrObjMapMap_newObj1 = new nsBS::TBaseStruct();
                _Deserialize( ptrObjMapMap_newObj1, second_e1 );
            }
            ptrObjMapMap_c1.insert( { ptrObjMapMap_e1.first, ptrObjMapMap_newObj1 } );
        }
        p->ptrObjMapMap.insert( { ptrObjMapMap_e0.first, ptrObjMapMap_c1 } );
    }
    
    auto& spObjMapMap_src0 = json["spObjMapMap"].object_items();
    for ( auto& spObjMapMap_e0 : spObjMapMap_src0 )
    {
        std::map<std::string,std::shared_ptr<nsBS::TBaseStruct>> spObjMapMap_c1;
        auto& spObjMapMap_src1 = spObjMapMap_e0.second.object_items();
        for ( auto& spObjMapMap_e1 : spObjMapMap_src1 )
        {
            auto& first_e1 = spObjMapMap_e1.first;
            auto& second_e1 = spObjMapMap_e1.second;
            std::shared_ptr<nsBS::TBaseStruct> spObjMapMap_newObj1;
            if ( second_e1.is_null() == false )
            {
                spObjMapMap_newObj1.reset( new nsBS::TBaseStruct() );
                _Deserialize( spObjMapMap_newObj1.get(), second_e1 );
            }
            spObjMapMap_c1.insert( { spObjMapMap_e1.first, spObjMapMap_newObj1 } );
        }
        p->spObjMapMap.insert( { spObjMapMap_e0.first, spObjMapMap_c1 } );
    }
    
    auto& colossalMember_src0 = json["colossalMember"].object_items();
    for ( auto& colossalMember_e0 : colossalMember_src0 )
    {
        std::vector<std::map<int,std::vector<std::map<int,std::map<int,std::vector<std::vector<int>>>>>>> colossalMember_c1;
        auto& colossalMember_src1 = colossalMember_e0.second.array_items();
        for ( auto& colossalMember_e1 : colossalMember_src1 )
        {
            std::map<int,std::vector<std::map<int,std::map<int,std::vector<std::vector<int>>>>>> colossalMember_c2;
            auto& colossalMember_src2 = colossalMember_e1.object_items();
            for ( auto& colossalMember_e2 : colossalMember_src2 )
            {
                std::vector<std::map<int,std::map<int,std::vector<std::vector<int>>>>> colossalMember_c3;
                auto& colossalMember_src3 = colossalMember_e2.second.array_items();
                for ( auto& colossalMember_e3 : colossalMember_src3 )
                {
                    std::map<int,std::map<int,std::vector<std::vector<int>>>> colossalMember_c4;
                    auto& colossalMember_src4 = colossalMember_e3.object_items();
                    for ( auto& colossalMember_e4 : colossalMember_src4 )
                    {
                        std::map<int,std::vector<std::vector<int>>> colossalMember_c5;
                        auto& colossalMember_src5 = colossalMember_e4.second.object_items();
                        for ( auto& colossalMember_e5 : colossalMember_src5 )
                        {
                            std::vector<std::vector<int>> colossalMember_c6;
                            auto& colossalMember_src6 = colossalMember_e5.second.array_items();
                            for ( auto& colossalMember_e6 : colossalMember_src6 )
                            {
                                std::vector<int> colossalMember_c7;
                                auto& colossalMember_src7 = colossalMember_e6.array_items();
                                for ( auto& colossalMember_e7 : colossalMember_src7 )
                                {
                                    colossalMember_c7.push_back( (int)(colossalMember_e7.number_value()) );
                                }
                                colossalMember_c6.push_back( colossalMember_c7 );
                            }
                            colossalMember_c5.insert( { (int)(std::stod( colossalMember_e5.first )), colossalMember_c6 } );
                        }
                        colossalMember_c4.insert( { (int)(std::stod( colossalMember_e4.first )), colossalMember_c5 } );
                    }
                    colossalMember_c3.push_back( colossalMember_c4 );
                }
                colossalMember_c2.insert( { (int)(std::stod( colossalMember_e2.first )), colossalMember_c3 } );
            }
            colossalMember_c1.push_back( colossalMember_c2 );
        }
        p->colossalMember.insert( { (int)(std::stod( colossalMember_e0.first )), colossalMember_c1 } );
    }
    
    auto& intSuperMap_src0 = json["intSuperMap"].object_items();
    for ( auto& intSuperMap_e0 : intSuperMap_src0 )
    {
        std::map<int,std::map<int,std::map<int,int>>> intSuperMap_c1;
        auto& intSuperMap_src1 = intSuperMap_e0.second.object_items();
        for ( auto& intSuperMap_e1 : intSuperMap_src1 )
        {
            std::map<int,std::map<int,int>> intSuperMap_c2;
            auto& intSuperMap_src2 = intSuperMap_e1.second.object_items();
            for ( auto& intSuperMap_e2 : intSuperMap_src2 )
            {
                std::map<int,int> intSuperMap_c3;
                auto& intSuperMap_src3 = intSuperMap_e2.second.object_items();
                for ( auto& intSuperMap_e3 : intSuperMap_src3 )
                {
                    intSuperMap_c3.insert( { (int)(std::stod( intSuperMap_e3.first )), (int)(intSuperMap_e3.second.number_value()) } );
                }
                intSuperMap_c2.insert( { (int)(std::stod( intSuperMap_e2.first )), intSuperMap_c3 } );
            }
            intSuperMap_c1.insert( { (int)(std::stod( intSuperMap_e1.first )), intSuperMap_c2 } );
        }
        p->intSuperMap.insert( { (int)(std::stod( intSuperMap_e0.first )), intSuperMap_c1 } );
    }
    
    auto& intSuperVec_src0 = json["intSuperVec"].array_items();
    for ( auto& intSuperVec_e0 : intSuperVec_src0 )
    {
        std::vector<std::vector<std::vector<int>>> intSuperVec_c1;
        auto& intSuperVec_src1 = intSuperVec_e0.array_items();
        for ( auto& intSuperVec_e1 : intSuperVec_src1 )
        {
            std::vector<std::vector<int>> intSuperVec_c2;
            auto& intSuperVec_src2 = intSuperVec_e1.array_items();
            for ( auto& intSuperVec_e2 : intSuperVec_src2 )
            {
                std::vector<int> intSuperVec_c3;
                auto& intSuperVec_src3 = intSuperVec_e2.array_items();
                for ( auto& intSuperVec_e3 : intSuperVec_src3 )
                {
                    intSuperVec_c3.push_back( (int)(intSuperVec_e3.number_value()) );
                }
                intSuperVec_c2.push_back( intSuperVec_c3 );
            }
            intSuperVec_c1.push_back( intSuperVec_c2 );
        }
        p->intSuperVec.push_back( intSuperVec_c1 );
    }
    
    auto& boolSuperList_src0 = json["boolSuperList"].array_items();
    for ( auto& boolSuperList_e0 : boolSuperList_src0 )
    {
        std::list<std::list<std::list<bool>>> boolSuperList_c1;
        auto& boolSuperList_src1 = boolSuperList_e0.array_items();
        for ( auto& boolSuperList_e1 : boolSuperList_src1 )
        {
            std::list<std::list<bool>> boolSuperList_c2;
            auto& boolSuperList_src2 = boolSuperList_e1.array_items();
            for ( auto& boolSuperList_e2 : boolSuperList_src2 )
            {
                std::list<bool> boolSuperList_c3;
                auto& boolSuperList_src3 = boolSuperList_e2.array_items();
                for ( auto& boolSuperList_e3 : boolSuperList_src3 )
                {
                    boolSuperList_c3.push_back( boolSuperList_e3.bool_value() );
                }
                boolSuperList_c2.push_back( boolSuperList_c3 );
            }
            boolSuperList_c1.push_back( boolSuperList_c2 );
        }
        p->boolSuperList.push_back( boolSuperList_c1 );
    }
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsMathTools::TMatrix16* p, Jobj& obj )
{
    PUM::Push( obj, "_11", p->_11 );
    PUM::Push( obj, "_12", p->_12 );
    PUM::Push( obj, "_13", p->_13 );
    PUM::Push( obj, "_14", p->_14 );
    PUM::Push( obj, "_21", p->_21 );
    PUM::Push( obj, "_22", p->_22 );
    PUM::Push( obj, "_23", p->_23 );
    PUM::Push( obj, "_24", p->_24 );
    PUM::Push( obj, "_31", p->_31 );
    PUM::Push( obj, "_32", p->_32 );
    PUM::Push( obj, "_33", p->_33 );
    PUM::Push( obj, "_34", p->_34 );
    PUM::Push( obj, "_41", p->_41 );
    PUM::Push( obj, "_42", p->_42 );
    PUM::Push( obj, "_43", p->_43 );
    PUM::Push( obj, "_44", p->_44 );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsMathTools::TMatrix16* p, const json11::Json& json )
{
    POM::PopNum( json, "_11", p->_11 );
    POM::PopNum( json, "_12", p->_12 );
    POM::PopNum( json, "_13", p->_13 );
    POM::PopNum( json, "_14", p->_14 );
    POM::PopNum( json, "_21", p->_21 );
    POM::PopNum( json, "_22", p->_22 );
    POM::PopNum( json, "_23", p->_23 );
    POM::PopNum( json, "_24", p->_24 );
    POM::PopNum( json, "_31", p->_31 );
    POM::PopNum( json, "_32", p->_32 );
    POM::PopNum( json, "_33", p->_33 );
    POM::PopNum( json, "_34", p->_34 );
    POM::PopNum( json, "_41", p->_41 );
    POM::PopNum( json, "_42", p->_42 );
    POM::PopNum( json, "_43", p->_43 );
    POM::PopNum( json, "_44", p->_44 );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsMathTools::TMatrix9* p, Jobj& obj )
{
    PUM::Push( obj, "_11", p->_11 );
    PUM::Push( obj, "_12", p->_12 );
    PUM::Push( obj, "_13", p->_13 );
    PUM::Push( obj, "_21", p->_21 );
    PUM::Push( obj, "_22", p->_22 );
    PUM::Push( obj, "_23", p->_23 );
    PUM::Push( obj, "_31", p->_31 );
    PUM::Push( obj, "_32", p->_32 );
    PUM::Push( obj, "_33", p->_33 );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsMathTools::TMatrix9* p, const json11::Json& json )
{
    POM::PopNum( json, "_11", p->_11 );
    POM::PopNum( json, "_12", p->_12 );
    POM::PopNum( json, "_13", p->_13 );
    POM::PopNum( json, "_21", p->_21 );
    POM::PopNum( json, "_22", p->_22 );
    POM::PopNum( json, "_23", p->_23 );
    POM::PopNum( json, "_31", p->_31 );
    POM::PopNum( json, "_32", p->_32 );
    POM::PopNum( json, "_33", p->_33 );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsMathTools::TOrientation* p, Jobj& obj )
{
    Jobj axis_obj;
    _Serialize( &(p->axis), axis_obj );
    PUM::Push( obj, "axis", axis_obj );
    PUM::Push( obj, "angle", p->angle );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsMathTools::TOrientation* p, const json11::Json& json )
{
    auto& axis_json = json["axis"];
    _Deserialize( &(p->axis), axis_json );
    POM::PopNum( json, "angle", p->angle );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsMathTools::TPlane* p, Jobj& obj )
{
    PUM::Push( obj, "a", p->a );
    PUM::Push( obj, "b", p->b );
    PUM::Push( obj, "c", p->c );
    PUM::Push( obj, "d", p->d );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsMathTools::TPlane* p, const json11::Json& json )
{
    POM::PopNum( json, "a", p->a );
    POM::PopNum( json, "b", p->b );
    POM::PopNum( json, "c", p->c );
    POM::PopNum( json, "d", p->d );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsMathTools::TPoint2* p, Jobj& obj )
{
    PUM::Push( obj, "x", p->x );
    PUM::Push( obj, "y", p->y );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsMathTools::TPoint2* p, const json11::Json& json )
{
    POM::PopNum( json, "x", p->x );
    POM::PopNum( json, "y", p->y );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsMathTools::TQuaternion* p, Jobj& obj )
{
    PUM::Push( obj, "x", p->x );
    PUM::Push( obj, "y", p->y );
    PUM::Push( obj, "z", p->z );
    PUM::Push( obj, "w", p->w );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsMathTools::TQuaternion* p, const json11::Json& json )
{
    POM::PopNum( json, "x", p->x );
    POM::PopNum( json, "y", p->y );
    POM::PopNum( json, "z", p->z );
    POM::PopNum( json, "w", p->w );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsMathTools::TVector2* p, Jobj& obj )
{
    PUM::Push( obj, "x", p->x );
    PUM::Push( obj, "y", p->y );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsMathTools::TVector2* p, const json11::Json& json )
{
    POM::PopNum( json, "x", p->x );
    POM::PopNum( json, "y", p->y );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsMathTools::TVector3* p, Jobj& obj )
{
    PUM::Push( obj, "x", p->x );
    PUM::Push( obj, "y", p->y );
    PUM::Push( obj, "z", p->z );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsMathTools::TVector3* p, const json11::Json& json )
{
    POM::PopNum( json, "x", p->x );
    POM::PopNum( json, "y", p->y );
    POM::PopNum( json, "z", p->z );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsMathTools::TVector4* p, Jobj& obj )
{
    PUM::Push( obj, "x", p->x );
    PUM::Push( obj, "y", p->y );
    PUM::Push( obj, "z", p->z );
    PUM::Push( obj, "w", p->w );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsMathTools::TVector4* p, const json11::Json& json )
{
    POM::PopNum( json, "x", p->x );
    POM::PopNum( json, "y", p->y );
    POM::PopNum( json, "z", p->z );
    POM::PopNum( json, "w", p->w );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig* p, Jobj& obj )
{
    _Serialize( (nsReflectionCodeGenerator::TClassDesc*)p, obj);
    Jobj unpackHandler_obj;
    _Serialize( &(p->unpackHandler), unpackHandler_obj );
    PUM::Push( obj, "unpackHandler", unpackHandler_obj );
    PUM::Push( obj, "beginID", p->beginID );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig* p, const json11::Json& json )
{
    _Deserialize( (nsReflectionCodeGenerator::TClassDesc*)p, json);
    auto& unpackHandler_json = json["unpackHandler"];
    _Deserialize( &(p->unpackHandler), unpackHandler_json );
    POM::PopNum( json, "beginID", p->beginID );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TClassDesc* p, Jobj& obj )
{
    PUM::Push( obj, "exportDeclaration", p->exportDeclaration );
    PUM::Push( obj, "nameSpaceName", p->nameSpaceName );
    PUM::Push( obj, "className", p->className );
    PUM::Push( obj, "fileName", p->fileName );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TClassDesc* p, const json11::Json& json )
{
    POM::PopStr( json, "exportDeclaration", p->exportDeclaration );
    POM::PopStr( json, "nameSpaceName", p->nameSpaceName );
    POM::PopStr( json, "className", p->className );
    POM::PopStr( json, "fileName", p->fileName );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TConfig* p, Jobj& obj )
{
    Jobj targetForParsing_obj;
    _Serialize( &(p->targetForParsing), targetForParsing_obj );
    PUM::Push( obj, "targetForParsing", targetForParsing_obj );
    Jobj filter_obj;
    _Serialize( &(p->filter), filter_obj );
    PUM::Push( obj, "filter", filter_obj );
    Jobj targetForCodeGeneration_obj;
    _Serialize( &(p->targetForCodeGeneration), targetForCodeGeneration_obj );
    PUM::Push( obj, "targetForCodeGeneration", targetForCodeGeneration_obj );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TConfig* p, const json11::Json& json )
{
    auto& targetForParsing_json = json["targetForParsing"];
    _Deserialize( &(p->targetForParsing), targetForParsing_json );
    auto& filter_json = json["filter"];
    _Deserialize( &(p->filter), filter_json );
    auto& targetForCodeGeneration_json = json["targetForCodeGeneration"];
    _Deserialize( &(p->targetForCodeGeneration), targetForCodeGeneration_json );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TFilter* p, Jobj& obj )
{
    PUM::Push( obj, "attribute", p->attribute );
    
    Jarr extensions_c0;
    for ( int extensions_i0 = 0 ; extensions_i0 < p->extensions.size() ; extensions_i0++ )
    {
        auto& extensions_e0 = p->extensions[extensions_i0];
        extensions_c0.push_back( extensions_e0 );
    }
    PUM::Push( obj, "extensions", extensions_c0 );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TFilter* p, const json11::Json& json )
{
    POM::PopStr( json, "attribute", p->attribute );
    
    auto& extensions_src0 = json["extensions"].array_items();
    for ( auto& extensions_e0 : extensions_src0 )
    {
        p->extensions.push_back( extensions_e0.string_value() );
    }
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TImplementation* p, Jobj& obj )
{
    Jobj jsonSerializer_obj;
    auto p_jsonSerializer = p->jsonSerializer.get();
    if ( p_jsonSerializer )
    {
        _Serialize( p_jsonSerializer, jsonSerializer_obj );
        PUM::Push( obj, "jsonSerializer", jsonSerializer_obj );
    }
    else
        PUM::PushNull( obj, "jsonSerializer" );
    Jobj binaryMarshaller_obj;
    auto p_binaryMarshaller = p->binaryMarshaller.get();
    if ( p_binaryMarshaller )
    {
        _Serialize( p_binaryMarshaller, binaryMarshaller_obj );
        PUM::Push( obj, "binaryMarshaller", binaryMarshaller_obj );
    }
    else
        PUM::PushNull( obj, "binaryMarshaller" );
    Jobj sql_obj;
    auto p_sql = p->sql.get();
    if ( p_sql )
    {
        _Serialize( p_sql, sql_obj );
        PUM::Push( obj, "sql", sql_obj );
    }
    else
        PUM::PushNull( obj, "sql" );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TImplementation* p, const json11::Json& json )
{
    auto& jsonSerializer_json = json["jsonSerializer"];
    if ( jsonSerializer_json.is_null() == false )
    {
        if ( p->jsonSerializer.get() == nullptr )
            p->jsonSerializer.reset( new nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig() );
        _Deserialize( p->jsonSerializer.get(), jsonSerializer_json );
    }
    auto& binaryMarshaller_json = json["binaryMarshaller"];
    if ( binaryMarshaller_json.is_null() == false )
    {
        if ( p->binaryMarshaller.get() == nullptr )
            p->binaryMarshaller.reset( new nsReflectionCodeGenerator::TBinaryMarshallerGeneratorConfig() );
        _Deserialize( p->binaryMarshaller.get(), binaryMarshaller_json );
    }
    auto& sql_json = json["sql"];
    if ( sql_json.is_null() == false )
    {
        if ( p->sql.get() == nullptr )
            p->sql.reset( new nsReflectionCodeGenerator::TSqlGeneratorConfig() );
        _Deserialize( p->sql.get(), sql_json );
    }
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig* p, Jobj& obj )
{
    _Serialize( (nsReflectionCodeGenerator::TClassDesc*)p, obj);
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TJsonSerializerGeneratorConfig* p, const json11::Json& json )
{
    _Deserialize( (nsReflectionCodeGenerator::TClassDesc*)p, json);
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TSqlGeneratorConfig* p, Jobj& obj )
{
    _Serialize( (nsReflectionCodeGenerator::TClassDesc*)p, obj);
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TSqlGeneratorConfig* p, const json11::Json& json )
{
    _Deserialize( (nsReflectionCodeGenerator::TClassDesc*)p, json);
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TTargetForCodeGeneration* p, Jobj& obj )
{
    PUM::Push( obj, "directory", p->directory );
    PUM::Push( obj, "includeListFileName", p->includeListFileName );
    PUM::Push( obj, "header", p->header );
    Jobj implementation_obj;
    _Serialize( &(p->implementation), implementation_obj );
    PUM::Push( obj, "implementation", implementation_obj );
    
    Jobj typeCustomizerMap_c0;
    for ( auto& typeCustomizerMap_e0 : p->typeCustomizerMap )
    {
        typeCustomizerMap_c0.insert( { PUM::ConvertToString( typeCustomizerMap_e0.first ), typeCustomizerMap_e0.second } );
    }
    PUM::PushMap( obj, "typeCustomizerMap", typeCustomizerMap_c0 );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TTargetForCodeGeneration* p, const json11::Json& json )
{
    POM::PopStr( json, "directory", p->directory );
    POM::PopStr( json, "includeListFileName", p->includeListFileName );
    POM::PopStr( json, "header", p->header );
    auto& implementation_json = json["implementation"];
    _Deserialize( &(p->implementation), implementation_json );
    
    auto& typeCustomizerMap_src0 = json["typeCustomizerMap"].object_items();
    for ( auto& typeCustomizerMap_e0 : typeCustomizerMap_src0 )
    {
        p->typeCustomizerMap.insert( { typeCustomizerMap_e0.first, typeCustomizerMap_e0.second.string_value() } );
    }
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TTargetForParsing* p, Jobj& obj )
{
    
    Jarr directories_c0;
    for ( int directories_i0 = 0 ; directories_i0 < p->directories.size() ; directories_i0++ )
    {
        auto& directories_e0 = p->directories[directories_i0];
        directories_c0.push_back( directories_e0 );
    }
    PUM::Push( obj, "directories", directories_c0 );
    PUM::Push( obj, "recursive", p->recursive );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TTargetForParsing* p, const json11::Json& json )
{
    
    auto& directories_src0 = json["directories"].array_items();
    for ( auto& directories_e0 : directories_src0 )
    {
        p->directories.push_back( directories_e0.string_value() );
    }
    POM::PopBool( json, "recursive", p->recursive );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Serialize( nsReflectionCodeGenerator::TUnpackHandler* p, Jobj& obj )
{
    _Serialize( (nsReflectionCodeGenerator::TClassDesc*)p, obj);
    PUM::Push( obj, "method", p->method );
}
//---------------------------------------------------------------------------------------
void TJsonSerializer::_Deserialize( nsReflectionCodeGenerator::TUnpackHandler* p, const json11::Json& json )
{
    _Deserialize( (nsReflectionCodeGenerator::TClassDesc*)p, json);
    POM::PopStr( json, "method", p->method );
}
//---------------------------------------------------------------------------------------
