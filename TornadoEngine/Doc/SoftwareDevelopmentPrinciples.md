# Software development principles

## 0. Правила для C++

1. Cтараться минимизировать использование директивы #include в заголовочных файлах, переносить в соответствующий cpp/cc файл. Скрывать реализацию от использующего.  
2. Запрещено использовать using namespace SomeNameSpace; в заголовочных файлах.

## 1. YAGNI (You Aren’t Gonna Need It / Вам это не понадобится)

Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.
Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.
Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить их из мертвых.

## 2. DRY (Don’t Repeat Yourself / Не повторяйтесь)

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.
В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.

## 3. KISS (Keep It Simple, Stupid / Будь проще)

Простые системы будут работать лучше и надежнее.
Не придумывайте к задаче более сложного решения, чем ей требуется.
Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.

## 4. Big Design Up Front (Глобальное проектирование прежде всего)

Прежде чем переходить к реализации, убедитесь, что все хорошо продумано.
Составив план, вы избавите себя от необходимости раз за разом начинать с нуля.
Иногда в недостатках и процессах разработки архитектуры должно быть замешаны и другие люди. Чем раньше вы все это обсудите, тем лучше будет для всех.
Очень распространенный контраргумент заключается в том, что стоимость решения проблем зачастую ниже стоимости времени планирования. Чем с меньшим количеством ошибок столкнется пользователь, тем лучше будет его опыт. У вас может не быть другого шанса справиться с этими ошибками.

## 5. SOLID  

### S) Single-responsibility principle /Принцип единственной ответственности

Каждый объект, класс и метод должны отвечать только за что-то одно. Если ваш объект/класс/метод делает слишком много, вы получите спагетти-код. Вот пример:

``` cpp
std::string Save()
{
   auto saveResult = Save();
   ShowSaveResult(saveResult ? "Success" : "Fail");
   window->scrollbar->SetPostion(X);
}
```

Этот метод кажется безобидным, но на самом деле он делает слишком много:

- Сохраняет объект;
- Обрабатывает уведомление в UI;  
- Выполняет навигацию.  

Еще один побочный эффект такого кода – проблемы с тестированием. Запутанный функционал тестировать сложно.

### O) Open–closed principle / Принцип открытости-закрытости

Программные объекты должны быть открыты для расширения, но закрыты для модификации. Нельзя переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости.
Если вы изменяете сущность, чтобы сделать ее расширяемой, вы нарушили этот принцип.

### L) Liskov substitution principle / Принцип подстановки Лисков

Функции, которые используют ссылки на базовые классы, должны иметь возможность использовать объекты производных классов, не зная об этом.

### I) Interface segregation principle / Принцип разделения интерфейсов

Объекты не должны зависеть от интерфейсов, которые они не используют.
ПО должно разделяться на независимые части. Побочные эффекты необходимо сводить к минимуму, чтобы обеспечивать независимость.
Убедитесь, что вы не заставляете объекты реализовывать методы, которые им никогда не понадобятся. Вот пример:

``` cpp
class IAnimal
{
public:
    virtual void Eat() = 0;
    virtual void Walk() = 0;
    virtual void Fly() = 0;
    virtual void Swim() = 0;
}
```

Не все животные могут Fly, Walk или Swim, поэтому эти методы не должны быть частью интерфейса или должны быть необязательными.

### D) Dependency inversion principle / Принцип инверсии зависимостей

Полагаться на абстракции, а не на конкретные реализации. Компоненты ПО должны иметь низкую связность и высокую согласованность.

Заботиться нужно не о том, как что-то устроено, а о том, как оно работает. Простой пример – использование дат. Вы можете написать для них свой слой абстракции. Тогда если у вас сменится источник получения дат, вам нужно будет внести изменения в одном месте, а не в тысяче.
Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге они окупаются.

## 6. Avoid Premature Optimization / Избегайте преждевременной оптимизации

Убедитесь, что оптимизация действительно полезна.
Очень простой пример – масштабирование. Вы не станете покупать 40 серверов из предположения, что ваше новое приложение станет очень популярным. Вы будете добавлять серверы по мере необходимости.
Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функций на рынок.

## 7. Бритва Оккама

Не создавайте ненужных сущностей без необходимости. Будьте прагматичны — подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.

P.S. только вот кто определяет простой код или нет? Начальнику важна скорость написания и работоспособность. Исполнитель не будет смтремиться выполнять все принципы, потому что начальнику выполнение всех принципов не столь важно.
Главное быстро написать и сдать. А потом разберемся. НО только "потом разберемся" - это время и деньги. Сам исполнитель конечно быстро разберется, но другие дольше и их будут за это ругать "Чего так долго копаешься? Там же всепросто!". Нет проверяющего за исполнителем.